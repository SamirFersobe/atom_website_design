import { WorkboxPlugin, CachedResponseWillBeUsedCallbackParam, RequestWillFetchCallbackParam, FetchDidSucceedCallbackParam, CacheKeyWillBeUsedCallbackParam } from 'workbox-core/types';
import { RouteConfig } from './Prefetcher';
declare type CurrentRequestMetadata = {
    isPrefetch?: boolean;
    requestStart?: number;
};
export default class DevtoolsPlugin implements WorkboxPlugin {
    private onResponse;
    private isEnabledFn;
    private routeConfig?;
    private currentRequests;
    constructor({ onResponse, routeConfig, isEnabledFn, }: {
        onResponse: Function;
        isEnabledFn: Function;
        routeConfig?: RouteConfig;
    });
    /**
     * Stores information about a request to be used by subsequent plugin steps
     *
     * IMPORTANT We do **not** use a custom header to store the metadata: a custom header leads
     * to CORS pre-flight requests when using cache on a different origin, and those would likely
     * reject our header.
     * (more info https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests)
     *
     * Unfortunately, there does not seem to be another way to (or if there is, feel free to fix this):
     * - store information on the request instance that we be passed along to subsequent steps
     * - identify a request uniquely with some sort of internal id
     *
     * For now, the solution is to use the normalized cache key to identify each request "uniquely",
     * although that would lead to inconsistent results if a same request happens multiple time concurrently.
     * It also adds overhead, especially for POST graphql query which serializes the body.
     *
     * After CURRENT_REQUEST_MAP_CLEANUP_DELAY, the metadata is cleared to avoid a memory leak.
     * We don't clear explicitly from cachedResponseWillBeUsed/fetchDidSucceed, as it very complex (impossible?) to do it right:
     * - we would need a counter on the current requests to be sure to not clear the metadata from concurrent equivalent request
     * - incrementing/decrementing because we don't know in advance through which
     *   plugin functions the request will go through, which is the first and which
     *   is the last. We could make assumptions but that would lead to fragility.
     */
    saveRequestMetadata(request: Request, metadata: CurrentRequestMetadata): Promise<void>;
    getRequestMetadata(request: Request): Promise<CurrentRequestMetadata>;
    /**
     * Notes:
     * - It seems that we cannot add arbitrary attributes to the request object
     *   so the best we can do is to store request info in a memory hash-map
     */
    requestWillFetch({ request }: RequestWillFetchCallbackParam): Promise<Request>;
    /**
     * Called when an object is read from or written to the cache.
     *
     * Notes:
     * - It seems that we cannot add arbitrary attributes to the request object
     *   so the best we can do is to store request info in a memory hash-map
     *
     * - In case of cache 'read', we keep track of prefetch request so that we can identify them later
     *   in `cachedResponseWillBeUsed`, which is called for both hit or miss.
     *   Why here and not on response? Because in `cachedResponseWillBeUsed` we only get the cache-normalized request
     *   where layer0_dt_pf query string got removed
     */
    cacheKeyWillBeUsed({ request, mode }: CacheKeyWillBeUsedCallbackParam): Promise<Request>;
    cachedResponseWillBeUsed({ request, cachedResponse: response, }: CachedResponseWillBeUsedCallbackParam): Promise<Response | undefined>;
    fetchDidSucceed({ request, response }: FetchDidSucceedCallbackParam): Promise<Response>;
}
export {};
