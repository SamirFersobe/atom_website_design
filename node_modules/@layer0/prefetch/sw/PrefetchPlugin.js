"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("@layer0/core/constants");
const constants_2 = require("../constants");
const constants_3 = require("../constants");
const log_1 = __importDefault(require("./log"));
const prefetch_1 = require("./prefetch");
const getServiceWorkerMaxAge_1 = __importDefault(require("./getServiceWorkerMaxAge"));
const origin = new URL(self.origin);
function isPrefetchRequest(request) {
    return new URL(request.url).searchParams.has(constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM);
}
exports.isPrefetchRequest = isPrefetchRequest;
async function normalizeRequestUrlForCache(request, { cacheHost } = {}) {
    request = request.clone();
    const url = new URL(request.url);
    // When reading/writing cacheHost URLs convert them back to origin
    if (cacheHost && url.hostname == cacheHost.hostname) {
        url.host = origin.host;
        url.protocol = origin.protocol;
    }
    const method = request.method.toLowerCase();
    // For non-GET requests, we need to add the request body to the cache key by appending in to the URL query string
    if (method !== 'get') {
        let body = await request.text();
        const bodyParam = url.searchParams.get(constants_1.POST_BODY_QUERY_PARAM);
        if (!bodyParam && body) {
            url.searchParams.set(constants_1.POST_BODY_QUERY_PARAM, encodeURIComponent(body));
        }
        // add method to the cache key so that we can cache requests to the same path with different methods
        url.searchParams.set(constants_1.METHOD_QUERY_PARAM, request.method.toLowerCase());
    }
    // remove layer0_prefetch, layer0_dt_pf and layer0_prefetch_ttl query params so that prefetches and real requests
    // return from the same cache space
    url.searchParams.delete(constants_1.THROTTLED_QUERY_PARAM);
    url.searchParams.delete(constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM);
    url.searchParams.delete(constants_1.PREFETCH_TTL_PARAM);
    // Decode query parameters both when writing to cache and when reading
    // from cache. This ensures the cache is used no matter whether the URL
    // is encoded in either step.
    decodeQueryParams(url);
    return url.toString();
}
exports.normalizeRequestUrlForCache = normalizeRequestUrlForCache;
class PrefetchPlugin {
    constructor({ incrementRead, incrementWrite, cacheHost, prefetchUpstreamRequests, convertToGet, method, }) {
        this.incrementRead = incrementRead;
        this.incrementWrite = incrementWrite;
        this.cacheHost = cacheHost;
        this.prefetchUpstreamRequests = prefetchUpstreamRequests;
        this.convertToGet = convertToGet;
        this.method = method;
    }
    async requestWillFetch({ request }) {
        if (this.convertToGet && this.method !== 'get') {
            const url = new URL(request.url);
            // if the request is not a GET, then it's ok to modify the request and bump
            // the priority since this means it is the real (non-prefetch) request (a
            // prefetch request will not come in as anything but a GET)
            const headers = new Headers(request.headers);
            let body = await request.clone().text();
            url.searchParams.set(constants_1.POST_BODY_QUERY_PARAM, body);
            return new Request(url.toString(), {
                method: 'get',
                headers,
                redirect: request.redirect,
            });
        }
        else {
            // We need to send a clone of the request so that we can read the request body and use
            // it in the cache key in the write phase of the cacheKeyWillBeUsed method.
            return request.clone();
        }
    }
    /**
     * Called when an object is read from or written to the cache.  Here we
     * compute cache stats and ensure that ?layer0_prefetch is removed from the cache key so
     * that future requests for prefetched resources will match.
     */
    async cacheKeyWillBeUsed({ request, mode }) {
        if (!isPrefetchRequest(request)) {
            if (mode === 'read') {
                this.incrementRead();
            }
            else {
                this.incrementWrite();
            }
        }
        return normalizeRequestUrlForCache(request, { cacheHost: this.cacheHost });
    }
    /**
     * Called when a response is about to be written to the cache.
     */
    async cacheWillUpdate({ response, request, event }) {
        // If prefetchUpstreamRequests is set, we only prefetch the html pages in SPA mode
        // (e.g Angular) to get the upstream requests response header.  We don't actually want
        // to serve the html from the cache, so this returns null:
        if (this.prefetchUpstreamRequests) {
            const backendRequests = response.headers.get(constants_3.BACKEND_REQUESTS_RESPONSE_HEADER_NAME);
            if (backendRequests) {
                const urlsToPrefetch = backendRequests.split(';');
                urlsToPrefetch.forEach(url => {
                    if (url)
                        prefetch_1.prefetch(url);
                });
            }
            return null;
        }
        // Get the maxage for storing in the service worker cache from x-sw-cache-control
        // Only responses from routes with cache({ browser: { serviceWorkerSeconds: (value) }}) will have this.
        // We should only cache non-prefetch requests if they have browser.serviceWorkerSeconds explicitly set in the router.
        const maxAge = getServiceWorkerMaxAge_1.default(response);
        // Service workers do not handle redirects well. If a redirected response is put in the cache,
        // you'll see this error: "a ServiceWorker passed a redirected Response to FetchEvent.respondWith()
        // while RedirectMode is not â€˜follow"
        // Returning null here prevents the response from being cached
        if (response.redirected) {
            log_1.default(`${response.url} was not added to the cache because it was a redirect.`);
            return null;
            // @ts-ignore
        }
        else if (isPrefetchRequest(event.request) || maxAge > 0) {
            log_1.default(`${response.url} was added to the cache with key ${request.url} for ${maxAge || constants_2.DEFAULT_MAX_AGE_SECONDS} seconds.`);
            const headers = new Headers(response.headers);
            headers.set('date', new Date().toUTCString());
            // Change max-age in SW header to custom value from query param
            // If no param is presented the value will be the same
            // This value is read by CustomExpirationPlugin to determinate if the response is still "fresh"
            let swHeaderContent = headers.get(constants_2.SERVICE_WORKER_CACHE_CONTROL);
            swHeaderContent = swHeaderContent
                ? swHeaderContent.replace(/max-age=\d+/, `max-age=${maxAge}`)
                : `max-age=${maxAge}`;
            headers.set(constants_2.SERVICE_WORKER_CACHE_CONTROL, swHeaderContent);
            return new Response(response.body, { ...response, headers });
        }
        else {
            // For routes without an explicit serviceWorkerSeconds cache config, we only cache the
            // response if the request was a prefetch. So in other words, we always write prefetches
            // to the cache.
            log_1.default(`${response.url} was not cached because it was not a prefetch.`);
            return null;
        }
    }
}
exports.default = PrefetchPlugin;
/**
 * Mutates the searchParams object, ensuring that each value is decoded.
 * @param {URL} url The URL whose params should be decoded
 */
function decodeQueryParams(url) {
    const maybeDecode = (val) => {
        try {
            return decodeURIComponent(val);
        }
        catch (e) {
            // it will fail if the string has a % in it that isn't a URL-decoded entity,
            // so that means the string is already decoded so we can just return the value:
            return val;
        }
    };
    url.searchParams.forEach((param, key) => {
        url.searchParams.set(maybeDecode(key), maybeDecode(param));
    });
}
