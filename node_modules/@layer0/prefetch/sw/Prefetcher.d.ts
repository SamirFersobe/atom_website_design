import { WorkboxPlugin } from 'workbox-core/types';
import { HTTPMethod } from '@layer0/core/router/CacheOptions';
import { CustomCacheKeyConfig } from '@layer0/core/router/CustomCacheKey';
export declare class Stats {
    hits: number;
    misses: number;
}
export interface PrefetcherConfig {
    /**
     * Workbox plugins to use when handling a cacheable route.
     */
    plugins: WorkboxPlugin[];
    /**
     * An optional second domain from which to prefetch instead of the origin domain.
     */
    cacheHost?: string;
    /**
     * The default time to live for prefetched requests that do not specify a `cache({ browser: { serviceWorkerSeconds }})`
     * config in the router.
     */
    defaultMaxAgeSeconds?: number;
}
export declare type RouteConfig = {
    criteriaPath?: string;
    pattern: string;
    edgeMaxAgeSeconds?: number;
    maxAgeSeconds: number;
    method?: HTTPMethod;
    isPartialPathRoute: boolean;
    key?: CustomCacheKeyConfig[];
    convertToGet?: boolean;
    prefetchUpstreamRequests?: boolean;
};
export declare type DevtoolsRequestMessage = {
    type: 'layer0-devtools-request';
    timestamp: number;
    request: {
        method: string;
        url: string;
        prefetch: boolean;
    };
    response: {
        ttfb: number;
        status: number;
        headers: {
            [key: string]: string;
        };
    };
    browserCache: string;
    routeConfig?: RouteConfig;
};
export declare type DevtoolsAckMessage = {
    type: 'layer0-devtools-ack';
    bufferedDevtoolMessages: DevtoolsRequestMessage[];
};
/**
 * Handles prefetching and caching in the the service worker.  Responses
 * are cached based on the `browser.serviceWorkerSeconds` cache setting in your routes.
 *
 * **Example routes.js**
 *
 * ```js
 *  import { Router } from '@layer0/core/router'
 *
 *  module.exports = new Router()
 *    .match('/some/path', ({ cache }) => {
 *      cache({
 *        edge: {
 *          maxAgeSeconds: 60 * 60 * 24 // one day
 *        },
 *        browser: {
 *          serviceWorkerSeconds: 60 * 60 // one hour
 *        }
 *      })
 *    })
 * ```
 *
 * **Example Service Worker**
 *
 * ```js
 *  import { skipWaiting, clientsClaim } from 'workbox-core'
 *  import { Prefetcher } from '@layer0/prefetch/sw'
 *  import { precacheAndRoute } from 'workbox-precaching'
 *
 *  skipWaiting()
 *  clientsClaim()
 *  precacheAndRoute(self.__WB_MANIFEST || [])
 *
 *  new Prefetcher().route()
 * ```
 */
export default class Prefetcher {
    private readonly cacheableResponsePlugin;
    private readonly config;
    private readonly cacheHost?;
    private readonly cacheOrigins;
    private readonly stats;
    private devtoolsEnabled;
    /**
     * bufferedDevtoolMessages keeps track of the request received in the last BUFFER_DELAY_MS.
     */
    private bufferedDevtoolMessages;
    private clearDevtoolsRequestMessageTimeout?;
    constructor(config?: PrefetcherConfig);
    getRouteConfigsFromManifest(): {
        criteriaPath: any;
        pattern: any;
        method: any;
        maxAgeSeconds: any;
        edgeMaxAgeSeconds: any;
        returnsResponse: any;
        isPartialPathRoute: boolean;
        key: any;
        convertToGet: any;
        prefetchUpstreamRequests: any;
    }[];
    /**
     * Creates a fallback route that ensures that all non-asset requests are handled by the service worker so that
     * we properly cache (or not cache) based on x-sw-cache-control, and that all network requests are seen by the
     * Devtools.
     */
    private createFallbackRoute;
    /**
     * Adds a fetch event listener that serves content from the browser cache when available.  When
     * a request is not in the cache, it will be fetched from the network and added to the
     * cache if the route has `browser.serviceWorkerSeconds` defined in its `cache` setting or if the
     * request is a prefetch.
     */
    route(): this;
    cache(pattern: RegExp, maxAgeSeconds?: number): this;
    /**
     * Starts listening for messages from the browser
     */
    private initStats;
    /**
     * Here we implement a handshake protocol between the devtool window client and the service worker:
     * 1. Devtools sends the 'layer0-devtools-syn' event and starts listening for 'layer0-devtools-ack' event
     * 2. Service worker receives the 'layer0-devtools-syn' event and sends the 'layer0-devtools-ack' event
     *    along with the buffered messages that were received over the last BUFFER_DELAY_MS.
     *    This is because the window widget takes time to download, load and to start listening from
     *    Service worker message, while the latter is already receiving http requests.
     * 3. Devtools receives the 'layer0-devtools-ack' event, looks for its current page html request,
     *    which corresponds to that tab very first request, and loads requests past that one.
     * 4. Devtools starts listening for live 'layer0-devtools-request' events
     *
     * Notes:
     * - there is no 1-1 channel between window client and Service Worker, so all opened tab
     *   will see the 'layer0-devtools-ack' event. Only the ones in handshake phase will handle it.
     */
    private initDevtoolsHandshakeListener;
    /**
     * Send a postMessage event to all window client.
     * Notes:
     * - When used in multi-tabs, each Devtools will show data from all tabs.
     *   That's a bit buggy but it's the best we can do as it's very hard to establish 1-1 channels
     *   on ServiceWorker/Client interface, for example the message event from the window does not
     *   contain the clientId
     */
    private sendToAllClients;
    /**
     * Adds a message to this.bufferedDevtoolMessages and manages the buffer so that
     * we don't keep messages more than BUFFER_DELAY_MS.
     *
     * In case of inactivity we clear the whole buffer after BUFFER_DELAY_MS, so technically
     * a message can stay up to 2 x BUFFER_DELAY_MS in the buffer (a bit less than BUFFER_DELAY_MS old
     * when the latest message arrives and cleared BUFFER_DELAY_MS later)
     * @param message
     */
    private addDevtoolsRequestMessageToBuffer;
    /**
     * Remove message that are too old to stay in devtools message buffer
     */
    private trimDevtoolsRequestMessageBuffer;
    /**
     * If there's a cacheHost configured check whether the pattern to test
     * against is a partial pathname pattern. If so, check that the origin is
     * also correct: service worker's own origin or cacheHost origin
     * @param pattern A route pattern
     * @param isPartialPathRoute Set to true if the supplied pattern only matches the path, false if it matches the whole URL.
     * @param options.skipAssets Set to true to ignore request that are not 'document' or 'empty' (ie: audio, font, image, ...)
     * @return true if the request should be handled by the service worker.
     */
    private shouldIntercept;
    /**
     * Creates a DevtoolsPlugin object to be added to a caching strategy instance
     * @param routeConfig The route config for the given route
     * @private
     */
    private createDevtoolsPlugin;
    /**
     * Creates a workbox route.
     * @param routeConfig The route pattern and caching options specified within the route definition
     */
    private createRoute;
    /**
     * A Read is considered a Hit until a Write happens meaning it was a miss
     * This is based on the fragile assumption that a cache read *always* triggers a write
     * in case of cache miss, which is not true if the backend does not respond for example.
     *
     * This could be fixed by checking the presence of `response` in `cachedResponseWillBeUsed``
     * but that leads to other issues as we cannot discard Prefetch requests at that
     * stage.
     * We could implement the same Hack-ish solution as in DevtoolsPlugin to work around that,
     * but those simple stats are probably going away anyway.
     */
    private incrementRead;
    private incrementWrite;
    private onResponse;
}
