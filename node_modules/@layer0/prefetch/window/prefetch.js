"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const waitForServiceWorker_1 = __importDefault(require("./waitForServiceWorker"));
const constants_1 = require("@layer0/core/constants");
const getHostName_1 = __importDefault(require("./getHostName"));
const install_1 = require("./install");
// According to Fastly, 2^13 (8192) is the max number of bytes allowed for a URL:
const MAX_URL_BYTES = 2 ** 13;
const prefetched = new Set();
const defaults = {
    includeCacheMisses: false,
    cacheHost: undefined,
    spaRoutes: [],
    forcePrefetchRatio: 0,
};
let options = defaults;
/**
 * Configures prefetching options
 * @param opts
 */
function configure(opts) {
    options = { ...defaults, ...opts };
}
exports.configure = configure;
/**
 * Prefetches and caches the specified URL.
 *
 * **Example**
 *
 * ```js
 * import { prefetch } from '@layer0/prefetch/window
 *
 * // Prefetches the URL with default PrefetchConfiguration
 * prefetch('/some/url')
 *
 * // Prefetches the URL as fetch with custom PrefetchConfiguration
 * prefetch('/some/url', "fetch", {
 *     // Overrides the default Prefetch TTL or serviceWorkerSeconds value defined in routes.js
 *     maxAgeSeconds: 300, // 5 minutes
 *
 *     // Allows to override the default forcePrefetchRatio value from install() function
 *     includeCacheMisses: true
 * });
 * ```
 * @param {String} url The URL to prefetch
 * @param {String} as Value to use for the "as" attribute of the <link> tag
 * @param {PrefetchConfiguration} config Options to use for the prefetch
 */
async function prefetch(url, as = 'fetch', config = {
    cors: 'anonymous',
    includeCacheMisses: options.includeCacheMisses,
    forcePrefetchRatio: options.forcePrefetchRatio,
}) {
    var _a, _b, _c, _d, _e;
    // In case service-worker was not registered by our install() function,
    // this function will add eventListener manually
    install_1.listenForSwMessages();
    if (typeof url === 'undefined') {
        console.error(`prefetch() called with an undefined url`);
        return;
    }
    // Set values from global config if any of config options is missing
    // Set default value if global config value is undefined
    config.cors = (_a = config.cors) !== null && _a !== void 0 ? _a : 'anonymous';
    config.includeCacheMisses = (_c = (_b = config.includeCacheMisses) !== null && _b !== void 0 ? _b : options.includeCacheMisses) !== null && _c !== void 0 ? _c : false;
    config.forcePrefetchRatio = (_e = (_d = config.forcePrefetchRatio) !== null && _d !== void 0 ? _d : options.forcePrefetchRatio) !== null && _e !== void 0 ? _e : 0;
    // @ts-ignore
    if (config.headers) {
        console.warn('The prefetch `headers` configuration option has been removed as it is not compatible with the service-worker prefetch mechanism. Please set headers in your routes.js file with `setRequestHeader` if required.');
    }
    const cacheUrl = modifyUrl(url, config);
    if (typeof TextEncoder !== 'undefined' &&
        new TextEncoder().encode(cacheUrl).length > MAX_URL_BYTES) {
        console.warn(`URL is too many characters to prefetch and cache: ${cacheUrl}`);
        return;
    }
    // This causes all the prefetch request to be called even though they are already cached in SW,
    // but they should be served from SW cache anyway. The impact to the performance with hmtl DOM changes is minimal,
    // tested with 1k prefetch calls.
    if (prefetched.has(cacheUrl)) {
        let prefetchLink = document.querySelector(`link[href='${cacheUrl}']`);
        prefetchLink === null || prefetchLink === void 0 ? void 0 : prefetchLink.remove();
    }
    prefetched.add(cacheUrl);
    await waitForServiceWorker_1.default();
    const link = document.createElement('link');
    const { relList } = link;
    link.setAttribute('href', cacheUrl);
    if (config.cors) {
        link.setAttribute('crossorigin', config.cors);
    }
    link.setAttribute('rel', relList.supports('preload') && /* istanbul ignore next */ !relList.supports('prefetch')
        ? /* istanbul ignore next */ 'preload'
        : 'prefetch' // Safari does not support prefetch so we use preload instead
    );
    link.setAttribute('as', as);
    document.head.append(link);
}
exports.prefetch = prefetch;
function modifyUrl(url, config) {
    const { body, method, maxAgeSeconds } = config;
    const parsed = new URL(url, window.origin);
    maybeAddHeadParam(parsed);
    if (parsed.hostname === getHostName_1.default()) {
        // If we are prefetching from Layer0 sidecar, rewrite the URL to use the sidecar's domain name
        if (options.cacheHost) {
            const cacheHostUrl = new URL(`https://${options.cacheHost}`);
            parsed.hostname = cacheHostUrl.hostname;
            parsed.protocol = cacheHostUrl.protocol;
            parsed.port = cacheHostUrl.port;
        }
        appendSearchParam(parsed, constants_1.DEVTOOLS_PREFETCH_QUERY_PARAM, '1');
        maybeAddThrottleParam(parsed, config);
    }
    if (body) {
        appendSearchParam(parsed, constants_1.POST_BODY_QUERY_PARAM, body);
    }
    if (method) {
        appendSearchParam(parsed, constants_1.METHOD_QUERY_PARAM, method);
    }
    if (maxAgeSeconds && maxAgeSeconds > 0) {
        appendSearchParam(parsed, constants_1.PREFETCH_TTL_PARAM, maxAgeSeconds.toString());
    }
    return parsed.toString();
}
function appendSearchParam(url, name, value) {
    const separator = url.search.length ? '&' : '?';
    url.search += `${separator}${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
}
/**
 * Adds the query param that indicates to the service worker that a request may be throttled
 * @param url
 * @param config
 */
function maybeAddThrottleParam(url, config) {
    if (!config.includeCacheMisses && shouldAcceptThrottling(config)) {
        appendSearchParam(url, constants_1.THROTTLED_QUERY_PARAM, '1');
    }
}
/**
 * Returns true if the next prefetch request should only be served from the edge cache.
 * This is done by comparing a random number between 0 and 1 to options.forcePrefetchRatio
 */
function shouldAcceptThrottling(config) {
    return !config.forcePrefetchRatio || Math.random() > config.forcePrefetchRatio;
}
function maybeAddHeadParam(url) {
    options.spaRoutes.some(routePattern => {
        if (routePattern.test(url.pathname)) {
            appendSearchParam(url, constants_1.HEAD_QUERY_PARAM, '1');
            return true;
        }
    });
}
