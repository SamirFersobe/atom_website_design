"use strict";

const {
  AuthenticationError
} = require('./errors');

const {
  getApiKey,
  saveApiKey
} = require('./config');

const Api = require('./api');

const Logger = require('./logger');

class Context {
  constructor(argv) {
    let {
      apiUrl,
      token,
      local,
      dev,
      stage,
      verbose,
      nonInteractive,
      ignoreError
    } = argv;
    token = token || process.env.LAYER0_DEPLOY_TOKEN;
    if (local) this.apiUrl = 'http://localhost:3000';else if (dev) this.apiUrl = 'https://api.layer0-dev.co';else if (stage) this.apiUrl = 'https://api.layer0-stage.co';else this.apiUrl = apiUrl; // apiUrl argv has default value of production url, so it can be used as fallback

    this.verbose = verbose;
    this.nonInteractive = nonInteractive || !!token;
    this.apiKey = token || getApiKey(this.apiUrl);
    this.apiKeyOverride = !!token; // Will contain the name of authenticated user

    this.currentActor = null;
    this.api = new Api(this);
    this.logger = new Logger(this);
    this.isLocalDev = !/app\.layer0(-dev)?\.co/.test(this.apiUrl);
    this.ignoreErrors = [];

    if (ignoreError) {
      // Normalizing into an Array
      this.ignoreErrors = typeof ignoreError === 'string' ? [ignoreError] : ignoreError;
    }
  }

  onLogin(name, apiKey) {
    this.currentActor = {
      name
    };
    this.apiKey = apiKey;
    this.loginAction = null;
    saveApiKey(this.apiUrl, apiKey);
  }

  setLoginAction(action) {
    this.loginAction = action;
  }

  async checkAuthentication() {
    if (!this.apiKey) {
      return;
    }

    try {
      this.currentActor = await this.api.currentActor();
    } catch (e) {
      if (e instanceof AuthenticationError) {
        return;
      }

      throw e;
    }
  }

  logout() {
    this.currentActor = null;
    saveApiKey(this.apiUrl, null);
  }

}

module.exports = Context;