"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const convertParamsToBackReferences_1 = __importStar(require("../utils/convertParamsToBackReferences"));
const constants_1 = require("../constants");
const get_1 = __importDefault(require("../utils/get"));
const isEmpty_1 = __importDefault(require("../utils/isEmpty"));
const ResponseWriter_1 = __importDefault(require("../router/ResponseWriter"));
const Route_1 = __importDefault(require("../router/Route"));
const validateBackends_1 = __importDefault(require("../utils/validateBackends"));
const validateWriter_1 = require("../router/validateWriter");
const universalRouteUtils_1 = require("../router/universalRouteUtils");
const slash_1 = __importDefault(require("slash"));
const FAR_FUTURE_TTL = 60 * 60 * 24 * 365 * 10;
/**
 * A substitute implementation of `ResponseWriter` that creates the contents of `layer0.json`, which
 * is used to generate edge code.
 */
class EdgeResponseWriter extends ResponseWriter_1.default {
    /**
     * @param req The `HttpRequest` object
     * @param res The `HttpResponse` object
     * @param route The route being hit
     * @param context The request context
     */
    constructor(_req, _res, route, context) {
        super(_req, _res, route, context); // istanbul ignore next - this is a known issue with TypeScript
        // Many of the methods such as updateRequestHeader assume transform.request
        // and transform.response are initialized to empty arrays by the constructor.
        this.stream = () => { };
        this.setRequestHeader = (name, value) => {
            validateWriter_1.validateSetRequestHeader(name);
            this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.setHeader,
                name,
                value,
            });
        };
        this.updateRequestHeader = (name, match, replace) => {
            validateWriter_1.validateUpdateRequestHeader(name);
            this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updateHeader,
                name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        this.removeRequestHeader = (name) => {
            validateWriter_1.validateRemoveRequestHeader(name);
            this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.removeHeader,
                name,
            });
        };
        this.setResponseHeader = (name, value) => {
            validateWriter_1.validateSetResponseHeader(name);
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name,
                value,
            });
        };
        this.updateResponseHeader = (name, match, replace) => {
            validateWriter_1.validateUpdateResponseHeader(name);
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateHeader,
                name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        this.removeResponseHeader = (name) => {
            validateWriter_1.validateRemoveResponseHeader(name);
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeHeader,
                name,
            });
        };
        /**
         * Note:
         * * We allow x-0-surrogate-key upstream response headers to be set by the edge logic,
         * to equalizes what can be done in the serverless vs what can be done in the edge.
         * * We do not extend this to other response headers because there are many that are
         * set internally in VCL (e.g. x-0-version, x-0-shield-response, x-0-isg-loading-page-served,
         * x-0-caching-status, and so on) which if affected would interfere with the correct
         * functioning of the service.
         */
        this.setUpstreamResponseHeader = (name, value) => {
            if (name.toLowerCase() != constants_1.HTTP_HEADERS.x0SurrogateKey) {
                validateWriter_1.validateSetResponseHeader(name);
            }
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.setHeader,
                name,
                value,
            });
        };
        this.updateUpstreamResponseHeader = (name, match, replace) => {
            validateWriter_1.validateUpdateResponseHeader(name);
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateHeader,
                name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        this.removeUpstreamResponseHeader = (name) => {
            validateWriter_1.validateRemoveResponseHeader(name);
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeHeader,
                name,
            });
        };
        this.addResponseCookie = (name, value) => {
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.addCookie,
                name,
                value,
            });
        };
        this.updateResponseCookie = (name, match, replace) => {
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.updateCookie,
                name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        this.removeResponseCookie = (name) => {
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.removeCookie,
                name,
            });
        };
        this.addUpstreamResponseCookie = (name, value) => {
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.addCookie,
                name,
                value,
            });
        };
        this.updateUpstreamResponseCookie = (name, match, replace) => {
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.updateCookie,
                name,
                valueRegex: match.source,
                replaceValue: replace,
            });
        };
        this.removeUpstreamResponseCookie = (name) => {
            this.edgeConfig.transform.upstreamResponse.push({
                action: constants_1.ACTIONS.removeCookie,
                name,
            });
        };
        /**
         * Sends a redirect from the edge
         *
         * In case of a complex redirect where the router needs to parse query string
         * from the matched request, or inject query strings in the redirect, we delegate
         * the response to Serverless compute and cache it for a very long time.
         *
         *
         * @param to The destination URL
         * @param statusCode The http response status.
         */
        this.redirect = (to, options = {}) => {
            const { to: toPath, statusCode, query } = this._readRedirectParams(to, options);
            const addQueryString = !isEmpty_1.default(query);
            const writerParam = convertParamsToBackReferences_1.getBackReferences(Route_1.default.pathWithQueryString(toPath, query));
            const parseQueryString = this.shouldParseQueryString(writerParam);
            // Complex redirects manipulating query string are delegated to compute and cached "for ever".
            // Cache key includes query string by default so every path / query string
            // combination is cached independently, which is what we want as redirects
            // location header includes original request's query string
            if (parseQueryString || addQueryString) {
                this.cache({
                    edge: {
                        maxAgeSeconds: FAR_FUTURE_TTL,
                    },
                });
                this.proxy(constants_1.BACKENDS.js);
                return;
            }
            this.setEdgeRoute({ action: constants_1.ACTIONS.syntheticRes, statusCode });
            this.edgeConfig.transform.response.push({
                action: constants_1.ACTIONS.setHeader,
                name: constants_1.HTTP_HEADERS.location,
                value: '${url}',
            });
            if (this.route.criteria.path) {
                // This applies the 'to' argument, interpolate path params from the original request
                // and appends original request's query strings (hence the added path-to-regexp matcher and added
                // back reference)
                const valueRegex = Route_1.default.toEdgeRegexString(this.route.criteria.path + '{(\\?[^#]+)}?');
                const matchParams = convertParamsToBackReferences_1.getBackReferences(this.route.criteria.path);
                const replaceValue = convertParamsToBackReferences_1.default(this.route.criteria.path, toPath) +
                    `\\${Object.keys(matchParams).length + 1}`;
                this.edgeConfig.transform.response.push({
                    action: constants_1.ACTIONS.updateHeader,
                    name: constants_1.HTTP_HEADERS.location,
                    valueRegex,
                    replaceValue,
                });
            }
            else {
                // This is a very special case where there is no path matcher, which is generally
                // the case for fallback routes.
                // We only extract the query string from the request path and
                // apply them to the redirect 'to'.
                this.edgeConfig.transform.response.push({
                    action: constants_1.ACTIONS.updateHeader,
                    name: constants_1.HTTP_HEADERS.location,
                    valueRegex: Route_1.default.toEdgeRegexString('([^?]*){(\\?[^#]+)}?'),
                    replaceValue: `${toPath}\\2`,
                });
            }
        };
        /**
         * Serves static assets.
         * @param path The request path
         */
        this.serveStatic = (path, { permanent, exclude, onNotFound, loadingPage, expiresSeconds, statusCode, statusMessage, disableAutoPublish, } = {}) => {
            if (path && !path.startsWith('/'))
                path = `/${path}`;
            const fsPath = [];
            let loadingPageTransform;
            if (loadingPage) {
                fsPath.push(loadingPage);
                loadingPageTransform = {
                    valueRegex: this.route.toEdgeRegexString(),
                    replaceValue: convertParamsToBackReferences_1.default(this.route.criteria.path, loadingPage),
                };
            }
            if (path) {
                this.updatePath(slash_1.default(path));
            }
            if (typeof path === 'string') {
                fsPath.push(path);
            }
            const isPermanent = permanent === true || get_1.default(permanent, 'enabled') || false;
            this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: isPermanent ? constants_1.BACKENDS.permanentStatic : constants_1.BACKENDS.static,
                fsPath,
                fsExclude: exclude,
                fallbackToCompute: onNotFound != null,
                loadingPage: loadingPageTransform,
                expiresSeconds,
                statusMessage,
                statusCode,
                disableAutoPublish,
            });
            return Promise.resolve();
        };
        this.verifyJwt = (options) => {
            this.edgeConfig.jwtVerification = options;
            return Promise.resolve();
        };
        /**
         * Proxies from the edge
         * @param backend
         * @param config
         * @param config.path
         */
        this.proxy = (backend, { path, transformResponse, transformRequest } = {}) => {
            validateBackends_1.default(backend);
            if (transformResponse != null || transformRequest != null || typeof path === 'function') {
                backend = constants_1.BACKENDS.js;
            }
            else if (typeof path === 'string') {
                // Only rewrite the request path if we're not going through compute, otherwise the router
                // in compute would match the wrong route
                this.updatePath(path);
            }
            this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend,
            });
            return Promise.resolve();
        };
        /**
         * Rewrites the request path.
         */
        this.updatePath = (destination) => {
            let replacePathValue = convertParamsToBackReferences_1.default(this.route.criteria.path, destination);
            // Makes path definition more flexible, allowing path with no / prefix (ex: { path: ':path' })
            if (replacePathValue[0] !== '/') {
                replacePathValue = `/${replacePathValue}`;
            }
            this.edgeConfig.transform.request.push({
                action: constants_1.ACTIONS.updatePath,
                valueRegex: this.route.toEdgeRegexString(),
                replaceValue: replacePathValue,
            });
        };
        /**
         * Creates the edge cache config
         * @param config
         */
        this.cache = (config) => {
            const { edge, browser, key } = config;
            if (edge) {
                const { maxAgeSeconds, staleWhileRevalidateSeconds, forcePrivateCaching } = edge;
                this.edgeConfig.cache = {
                    maxAgeSeconds,
                    staleWhileRevalidateSeconds,
                    forcePrivateCaching,
                };
            }
            else if (edge === false) {
                this.edgeConfig.cache = {
                    disabled: true,
                };
            }
            if (key) {
                if (!this.edgeConfig.cache) {
                    this.edgeConfig.cache = {};
                }
                this.edgeConfig.cache.customKey = key.toJSON();
            }
            if (browser || browser === false) {
                const { maxAgeSeconds, serviceWorkerSeconds } = browser || { maxAgeSeconds: 0 };
                if (serviceWorkerSeconds && maxAgeSeconds && maxAgeSeconds > 0) {
                    throw new Error('When service worker caching is set, the browser max age must be set to zero. Refer to https://docs.layer0.co/guides/caching#section_caching_a_response');
                }
                if (maxAgeSeconds === 0) {
                    this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: 'private, no-store, no-cache',
                    });
                }
                else if (maxAgeSeconds) {
                    // Here we use "private" instead of "public" to prevent downstream CDNs from caching the asset
                    // Since we already have an explicit way to cache at edge, we choose to keep browser and edge
                    // caching totally separate.
                    this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.cacheControl,
                        value: `private, max-age=${maxAgeSeconds}`,
                    });
                }
                if (serviceWorkerSeconds) {
                    this.edgeConfig.transform.response.push({
                        action: constants_1.ACTIONS.setHeader,
                        name: constants_1.HTTP_HEADERS.xSwCacheControl,
                        value: `max-age=${serviceWorkerSeconds}`,
                    });
                }
            }
        };
        /**
         * Sends string content back to client. If content is a string, the response will be sent
         * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
         * StatusCode defaults to 200 on routes which is set by createEdgeConfig. On error routes we send the status code
         * as null, since we need to preserve the status code of the failed request unless it is provided.
         * @param content The content to send to the browser
         * @param statusCode The HTTP status code.
         * @param statusMessage The HTTP status message
         */
        this.send = (content, statusCode, statusMessage) => {
            if (typeof content === 'function') {
                this.render();
            }
            else {
                this.setEdgeRoute({
                    action: constants_1.ACTIONS.syntheticRes,
                    statusCode,
                    statusMessage,
                    content,
                });
            }
        };
        /**
         * Computed responses are always proxied to the serverless backend.
         * @param callback
         */
        this.compute = (callback) => {
            this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
        };
        /**
         * Passes request and response to the specified callback, which should
         * handle rendering the response as a string
         */
        this.render = () => {
            this.setEdgeRoute({
                action: constants_1.ACTIONS.proxy,
                backend: constants_1.BACKENDS.js,
            });
            return Promise.resolve();
        };
        this.edgeConfig = {
            transform: {
                request: [],
                upstreamResponse: [],
                response: [],
            },
        };
    }
    shouldParseQueryString(writerParam) {
        const query = this.route.criteria.query;
        if (query === undefined) {
            return false;
        }
        return Object.keys(query).some(key => {
            const value = query[key];
            return universalRouteUtils_1.isParamMatcher(value) && !!writerParam[key];
        });
    }
    /**
     * Sets the edge route and injects the x-0-route header value.
     *
     * Notes:
     * - We need `x-0-route` header for statistics so we log it in the edge.
     * We thus set it on the request, which allows us to log it, but in the edge
     * code we unset this header before going upstream which avoids any leaking.
     * - route.criteria.path can be null (fallback, or different match method)
     * so we check that the path exists or injecting the request path as a fallback.
     * - We don't allow upstream to dicate the `vary` header - developers can use
     * our custom cache key mechanism which is a superset anyways. The only
     * header we allow in the `vary` is `accept-encoding` which then shards
     * the cache depending on the encoding that the user agent is accepting.
     * In any case we already include `accept-encoding` in the default cache
     * key so including it in `vary` is superfluous *except* that downstream
     * caches might use it.
     *
     * @private
     */
    setEdgeRoute(route) {
        this.edgeConfig.route = route;
        this.edgeConfig.transform.upstreamResponse.push({
            action: constants_1.ACTIONS.setHeader,
            name: constants_1.HTTP_HEADERS.vary,
            value: constants_1.HTTP_HEADERS.acceptEncoding,
        });
    }
}
exports.default = EdgeResponseWriter;
