"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = __importDefault(require("../config"));
const toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
const toHttpMethodMatchRegex_1 = __importDefault(require("../utils/toHttpMethodMatchRegex"));
const convertStringMatcherToRegex_1 = __importDefault(require("../utils/convertStringMatcherToRegex"));
const EdgeResponseWriter_1 = __importDefault(require("./EdgeResponseWriter"));
const constants_1 = require("../constants");
const RequestContext_1 = __importDefault(require("../router/RequestContext"));
const universalRouteUtils_1 = require("../router/universalRouteUtils");
const EdgeErrorPageResponseWriter_1 = __importDefault(require("./EdgeErrorPageResponseWriter"));
/**
 * Returns cache object
 *
 * Notes:
 * - Method caching is only allowed when it's explicit:
 * 1. The matching was explicitly done on `post` and other methods and
 * 2. The caching properties were defined on the same route.
 *
 * @private
 */
function buildRouteCacheKeysFromEdgeWriter({ edgeConfig }, matchExplicitMethod) {
    var _a, _b;
    // istanbul ignore next - edgeConfig.cache?.maxAgeSeconds is apparently untestable as it always shows as uncovered
    if (edgeConfig.cache && ((_a = edgeConfig.cache) === null || _a === void 0 ? void 0 : _a.maxAgeSeconds) &&
        ((_b = edgeConfig.cache) === null || _b === void 0 ? void 0 : _b.maxAgeSeconds) > 0 &&
        matchExplicitMethod) {
        return {
            ...edgeConfig.cache,
            matchExplicitMethod,
        };
    }
    return edgeConfig.cache;
}
/**
 * Returns route action
 * @private
 */
function buildRouteActionFromEdgeWriter({ edgeConfig }, isErrorRoute) {
    var _a;
    const route = edgeConfig.route;
    // On error routes we don't use the default statusCode since we must preserve the status code
    // of the error route.
    if (((_a = edgeConfig.route) === null || _a === void 0 ? void 0 : _a.action) === constants_1.ACTIONS.syntheticRes &&
        !edgeConfig.route.statusCode &&
        !isErrorRoute) {
        edgeConfig.route.statusCode = 200;
    }
    return route;
}
/**
 * Returns transformation object
 * @private
 */
function buildTransformFromEdgeWriter({ edgeConfig }) {
    return edgeConfig.transform;
}
/**
 * Returns the jwtVerification object (if any) validation is performed earlier
 * @private
 */
function buildVerifyJwtFromEdgeWriter({ edgeConfig, }) {
    return edgeConfig.jwtVerification;
}
function transformBodyCriteria(obj) {
    return Object.entries(obj).reduce((memo, [key, value]) => {
        if (value instanceof RegExp) {
            memo[key] = convertStringMatcherToRegex_1.default(value);
        }
        else if (typeof value === 'object' && value !== null) {
            memo[key] = transformBodyCriteria(value);
        }
        else {
            memo[key] = convertStringMatcherToRegex_1.default(value);
        }
        return memo;
    }, {});
}
/**
 * Build Outer Edge match configuration
 *
 * Notes:
 * - When resulting array is empty, it means that all requests should match
 * - If method matching is set to explicit method then set it in `matchExplicitMethod`
 * - All routes have implicit https protocol, so only if a criteria has explicitly been
 * set to http do we match for that protocol, otherwise we match https.
 *
 * @param route
 * @returns An array of match criteria
 * @private
 */
function buildMatcherFromRoute(route) {
    var _a;
    const match = [];
    const matchResp = [];
    let matchProtocolJavaScriptRegExpSource;
    let matchExplicitMethod;
    if (route.criteria.protocol) {
        let regex;
        // Because HTTP is a subset of HTTPS we make sure that when strings are used we match
        // the whole value rather than just a part of it.
        if (typeof route.criteria.protocol === 'string') {
            regex = new RegExp(`^${route.criteria.protocol}$`, 'i');
        }
        else {
            regex = new RegExp(route.criteria.protocol);
        }
        if (!regex.test('http') && !regex.test('https')) {
            throw new Error('Protocol matcher must match either "http" or "https"');
        }
        matchProtocolJavaScriptRegExpSource = regex.source;
    }
    if (route.criteria.path) {
        match.push({
            value: '${path}',
            matchRegex: route.toEdgeRegexString(),
        });
    }
    if (route.criteria.method) {
        let matchRegex;
        if (typeof route.criteria.method !== 'string') {
            matchRegex = route.criteria.method;
        }
        else {
            matchRegex = toHttpMethodMatchRegex_1.default(route.criteria.method);
            if (Object.values(constants_1.HTTP_METHODS).includes(route.criteria.method)) {
                matchExplicitMethod = route.criteria.method;
            }
        }
        match.push({
            value: '${method}',
            matchRegex: toEdgeRegex_1.default(matchRegex),
        });
    }
    if (route.criteria.headers) {
        Object.entries(route.criteria.headers).forEach(([name, value]) => {
            match.push({
                value: `\${req:${name}}`,
                matchRegex: convertStringMatcherToRegex_1.default(value),
            });
        });
    }
    // Match is executed on deliver phase. This is required for error pages.
    if ((_a = route.criteria.response) === null || _a === void 0 ? void 0 : _a.statusCode) {
        matchResp.push({
            value: `\${res:status}`,
            matchRegex: toEdgeRegex_1.default(route.criteria.response.statusCode),
        });
    }
    if (route.criteria.query) {
        Object.entries(route.criteria.query).forEach(([name, value]) => {
            // Dynamic query matcher (ex: { query: { id: ':id' } }) don't need to be
            // strictly matched against the route. They can be present or not.
            if (universalRouteUtils_1.isParamMatcher(value))
                return;
            match.push({
                value: `\${query:${name}}`,
                matchRegex: convertStringMatcherToRegex_1.default(value),
            });
        });
    }
    if (route.criteria.cookies) {
        Object.entries(route.criteria.cookies).forEach(([name, value]) => {
            match.push({
                value: `\${req:cookie:${name}}`,
                matchRegex: convertStringMatcherToRegex_1.default(value),
            });
        });
    }
    if (route.criteria.body) {
        match.push({
            matchBody: JSON.stringify({
                parse: route.criteria.body.parse,
                criteria: transformBodyCriteria(route.criteria.body.criteria),
            }),
        });
    }
    return {
        match,
        matchResp,
        matchExplicitMethod,
        matchProtocolJavaScriptRegExpSource,
    };
}
/**
 * Creates an outer edge manager config for the specified router by iterating through
 * each route and calling it with a mock request
 * and response.
 * @param router
 * @return An object containing the Edge config
 */
async function createEdgeConfig(router) {
    let destinations = {};
    if (!Object.keys(router.getDestinations()).length) {
        destinations = {
            default: await createDestination(router),
        };
    }
    else {
        for (let d in router.getDestinations()) {
            destinations[d] = await createDestination(router.getDestinations()[d]);
        }
    }
    return {
        version: getLayer0Version(),
        backends: {
            ...config_1.default.get('backends'),
        },
        destinations,
    };
}
exports.default = createEdgeConfig;
/**
 * Gets the version of @layer0/core.  For this to work in testing an entry needed
 * to be added to moduleNameMapper in the jest config specifically for package.json
 * @return {String}
 */
function getLayer0Version() {
    // We purposefully don't override this version so that we can see in edge
    // responses the *exact* version with which the edge was built.
    return require('../package.json').version;
}
async function createDestinationMapFunction(route, writer, faultyRoutes, isErrorRoute) {
    try {
        // @ts-ignore
        await route.handler(writer);
    }
    catch (e) {
        Error.captureStackTrace(e);
        faultyRoutes.push({
            route: route.toString(),
            stackTrace: e.stack,
        });
    }
    const { match, matchResp, matchExplicitMethod, matchProtocolJavaScriptRegExpSource } = buildMatcherFromRoute(route);
    return {
        // used when building .layer0 to assemble the s3 directory structure
        path: route.criteria.path,
        // Consumed by Cache metrics to build the route string
        routeJson: route.toJson(),
        match,
        matchResp,
        matchProtocolJavaScriptRegExpSource,
        cache: buildRouteCacheKeysFromEdgeWriter(writer, matchExplicitMethod),
        route: buildRouteActionFromEdgeWriter(writer, isErrorRoute),
        transform: buildTransformFromEdgeWriter(writer),
        jwtVerification: buildVerifyJwtFromEdgeWriter(writer),
    };
}
async function createDestination(router) {
    const faultyRoutes = [];
    const destination = {
        index: router.index,
        errorRoutes: await Promise.all(router
            .getRouteGroups()
            .getRoutes()
            .filter(route => route.isRespRoute())
            .map(route => createDestinationMapFunction(route, new EdgeErrorPageResponseWriter_1.default({
            url: '',
            headers: {},
        }, {}, route, new RequestContext_1.default()), faultyRoutes, true))),
        routes: await Promise.all(router
            .getRouteGroups()
            .getRoutes()
            .filter(route => !route.isRespRoute())
            .map(route => createDestinationMapFunction(route, new EdgeResponseWriter_1.default({
            url: '',
            headers: {},
        }, {}, route, new RequestContext_1.default()), faultyRoutes, false))),
    };
    // If any faulty routes occured, throw error with all faulty routes listed
    if (faultyRoutes.length) {
        let errorMessage = '\nErrors occurred while attempting to deploy your application to Layer0 edge.' +
            `\nThe following ${faultyRoutes.length > 1 ? 'routes' : 'route'} could not be processed:`;
        faultyRoutes.forEach(({ route, stackTrace }) => {
            errorMessage = errorMessage.concat(`\n* ${route}: ${stackTrace}`);
        });
        throw new Error(errorMessage);
    }
    return destination;
}
