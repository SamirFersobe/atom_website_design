"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const shelljs_1 = __importDefault(require("shelljs"));
const nonWebpackRequire_1 = __importDefault(require("../utils/nonWebpackRequire"));
// we don't bundle chalk because it's large and we only use it in development
const chalk = nonWebpackRequire_1.default('chalk');
/**
 * Runs the user's app in development mode
 * @param port The port on which to listen
 * @param local Describes how to construct the command that runs the app
 * @returns A promise that resolves when the app is ready to receive requests.
 */
function runLocalApp(port, options) {
    const { run, command } = options;
    // If dev server uses a manual run function, skip all command functionality
    if (run) {
        return run(port);
    }
    /* istanbul ignore next */
    if (!command)
        return;
    const label = chalk.grey(options.label || 'app');
    return new Promise((resolve, reject) => {
        var _a, _b;
        try {
            const childProcess = shelljs_1.default.exec(command(port), {
                async: true,
                env: { ...process.env, PORT: port.toString(), FORCE_COLOR: 'true' },
                silent: true,
            }, code => {
                if (code > 0) {
                    console.error(chalk.red('Layer0 encountered a fatal error while running your application. Exiting...'));
                    reject();
                    process.exit(code);
                }
                else {
                    resolve();
                }
            });
            /* istanbul ignore next */
            (_a = childProcess.stderr) === null || _a === void 0 ? void 0 : _a.on('data', data => process.stderr.write(`${label} ${data}`));
            const ready = options.ready || [];
            const filterOutput = options.filterOutput || ((_line) => true);
            /* istanbul ignore next */
            (_b = childProcess.stdout) === null || _b === void 0 ? void 0 : _b.on('data', data => {
                let matched = false;
                ready.some((pattern, i) => {
                    if (pattern.test(data)) {
                        ready.splice(i, 1);
                        matched = true;
                    }
                });
                if (ready.length === 0) {
                    resolve();
                }
                if (matched || !filterOutput(data)) {
                    return; // hide the ready line so that the user doesn't see two URLs and get confused.
                }
                process.stdout.write(`${label} ${data}`);
                if (!data.endsWith('\n')) {
                    process.stdout.write('\n');
                }
            });
        }
        catch (e) {
            reject(e);
        }
    });
}
exports.default = runLocalApp;
