"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const traverse_1 = __importDefault(require("@babel/traverse"));
const parser_1 = require("@babel/parser");
const routeFunctions = new Set(['get', 'put', 'post', 'patch', 'options', 'delete', 'match']);
/**
 * Parses and introspects the user's routes file.
 * @private
 * @param routerFile
 */
function parseRouter(routerFile) {
    const code = fs_1.readFileSync(routerFile, 'utf8');
    const ast = parser_1.parse(code, { sourceType: 'module', plugins: ['typescript'] });
    const results = [];
    // @ts-ignore
    traverse_1.default(ast, {
        CallExpression: (path) => {
            const call = path.node;
            const member = call.callee;
            const args = call.arguments;
            if (member.type !== 'MemberExpression' || member.property.type !== 'Identifier') {
                return;
            }
            const method = member.property;
            if (routeFunctions.has(method.name)) {
                // istanbul ignore if
                if (!method.loc) {
                    // istanbul ignore next
                    throw new Error('Source location not available');
                }
                try {
                    results.push({
                        criteria: getRouteCriteria(method.name, args[0], code),
                        line: method.loc.start.line,
                        column: method.loc.start.column,
                    });
                }
                catch (e) {
                    // will get here if the method's first argument is an unexpected type, which likely
                    // means this wasn't a method call on the router
                }
            }
        },
    });
    return results;
}
exports.default = parseRouter;
/**
 * Returns the criteria for the given route
 * @param method
 * @param criteriaNode
 * @param code
 */
function getRouteCriteria(method, criteriaNode, code) {
    // istanbul ignore if
    if (!criteriaNode.start || !criteriaNode.end) {
        // istanbul ignore next
        throw new Error('Source location not available');
    }
    const snippet = code.slice(criteriaNode.start, criteriaNode.end);
    let criteriaOrPath, criteria;
    eval(`criteriaOrPath = ${snippet}`);
    if (typeof criteriaOrPath === 'string') {
        criteria = {
            method,
            path: criteriaOrPath,
        };
    }
    else {
        criteria = criteriaOrPath;
    }
    return criteria;
}
