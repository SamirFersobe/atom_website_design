"use strict";
/* istanbul ignore file */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const shelljs_1 = __importDefault(require("shelljs"));
const path_1 = require("path");
const bundle_esbuild_1 = require("./bundle-esbuild");
const globby_1 = __importDefault(require("globby"));
// @ts-ignore
const unixify_1 = __importDefault(require("unixify"));
const chalk_1 = __importDefault(require("chalk"));
const config_1 = __importDefault(require("../config"));
const paths_1 = require("./paths");
const init_1 = require("../init");
const routeToFiles_1 = require("./routeToFiles");
const constants_1 = require("../constants");
const RouteGroup_1 = require("../router/RouteGroup");
const listSources_1 = __importDefault(require("./listSources"));
const resolveInPackage_1 = __importDefault(require("./resolveInPackage"));
const paths_2 = require("./paths");
const loadRouter_1 = __importDefault(require("../router/loadRouter"));
const source_1 = require("../source");
const parseRouter_1 = __importDefault(require("../parser/parseRouter"));
const Route_1 = __importDefault(require("../router/Route"));
const slash_1 = __importDefault(require("slash"));
/**
 * The class helps you bundle apps for deployment on Layer0.
 */
class DeploymentBuilder {
    constructor(appDir = process.cwd()) {
        // This structure has connasence of structure, names and types with Layer0 subaccount deployment lambda.
        this.assetExpiration = {};
        this.appDir = appDir;
        this.layer0Dir = path_1.join(this.appDir, paths_1.LAYER0_DIR);
        this.jsDir = path_1.join(this.appDir, paths_1.JS_DIR);
        this.staticAssetsDir = path_1.join(this.appDir, paths_1.ASSETS_DIR);
        this.permanentStaticAssetsDir = path_1.join(this.appDir, paths_1.PERMANENT_ASSETS_DIR);
        this.sourcesDir = path_1.join(this.appDir, paths_1.SOURCES_DIR);
    }
    /**
     * Logs a message to the console if process.env.debug is set to true
     * @param msg The message to log
     */
    log(...msg) {
        if (process.env.DEBUG === 'true') {
            console.log('[Layer0 BUILD]:', ...msg);
        }
    }
    /**
     * Runs a command.
     * @param path The command to run
     * @param options Options for shelljs
     * @return {Promise} A promise that resolves when the command is finished.
     */
    exec(command, options = {}) {
        return new Promise((resolve, reject) => {
            console.log(chalk_1.default.grey(`[Layer0] Running command: ${command}`));
            shelljs_1.default.exec(command, options, (code, stdout, stderr) => {
                if (code != 0)
                    return reject(new Error(stderr));
                return resolve(stdout);
            });
        });
    }
    /**
     * Adds an asset to the bundle for JavaScript workers
     * @param src The source path
     * @param dest An optional destination path within the lambda root directory.
     * If not provided, the destination path will be the same as the source path.
     * @param options Options for copySync
     * @return a self reference, suitable for chaining
     */
    addJSAsset(src, dest, options) {
        dest = dest || path_1.relative(process.cwd(), src);
        this.copySync(src, path_1.join(this.jsDir, dest), options);
        return this;
    }
    /**
     * Copies a file or directory into .layer0/src
     * @param src
     */
    addSource(src) {
        const dest = path_1.relative(this.appDir, src);
        this.copySync(src, path_1.join(this.sourcesDir, dest));
    }
    /**
     * Adds source files to the bundle based on:
     *
     *  - The `sources` property of layer0.config.js, or, if not present
     *  - All files committed to git.
     *
     * If sources is not present in layer0.config.js, and the project does not use git, an error will be thrown.
     */
    async addSources() {
        process.stdout.write('> Copying sources into bundle... ');
        for (let file of await listSources_1.default(this.appDir, config_1.default.get('sources', null))) {
            this.addSource(file);
        }
        process.stdout.write('done.\n');
    }
    /**
     * Adds the prod entry point from the connector attribute in layer0.config.js
     * @return a self reference, suitable for chaining
     */
    async addProdEntrypoint() {
        let connector = config_1.default.get('connector', 
        /* set by @layer0/cli/build when falling back to framework detection */
        process.env.LAYER0_CONNECTOR || null);
        if (connector) {
            let name = 'prod';
            let prod;
            if (connector.startsWith('.')) {
                // relative path
                prod =
                    [
                        path_1.join(this.appDir, connector, `${name}.cjs`),
                        path_1.join(this.appDir, connector, `${name}.mjs`),
                        path_1.join(this.appDir, connector, `${name}.js`),
                    ].find(file => fs_extra_1.existsSync(file)) || '';
            }
            else {
                // package name
                prod = path_1.join(resolveInPackage_1.default(connector, `${name}.js`));
            }
            if (fs_extra_1.existsSync(prod)) {
                this.addJSAsset(prod, paths_2.pathForBackend(constants_1.BACKENDS.js));
            }
        }
        return this;
    }
    /**
     * Adds a folder or file as static asset.
     * Also register directories as asset aliases when they contains an index.html file
     *
     * @param src The source path
     * @param dest An optional destination path in s3. If not provided, the destination path will be the same as the source path.
     * @return a self reference, suitable for chaining
     */
    addStaticAsset(src, dest, { permanent = false, exclude = [] } = {}) {
        dest = dest || path_1.relative(process.cwd(), src);
        permanent = permanent && process.env.LAYER0_DISABLE_PERMANENT_ASSETS !== 'true';
        const staticAssetDir = permanent ? this.permanentStaticAssetsDir : this.staticAssetsDir;
        const absoluteDest = path_1.join(staticAssetDir, dest);
        this.copySync(src, absoluteDest, {
            filter: file => !exclude.some(excludedFile => file.indexOf(excludedFile) >= 0),
        });
        return this;
    }
    /**
     * Ensures that all path/to/dir/index.html files in S3 have an alias for /path/to/dir. This
     * allows the edge to simply forward URLs like /foo to S3 and have S3 respond with /foo/index.html.
     * THis is critical to the functionality of Gatsby, Next.js, and other static site builders.
     */
    createStaticAssetAliases() {
        process.stdout.write('> Writing static asset aliases... ');
        const assetAliases = {};
        const dirs = [this.staticAssetsDir, this.permanentStaticAssetsDir];
        dirs.forEach(dir => {
            const files = globby_1.default.sync('**/index.html', {
                cwd: dir,
                onlyFiles: true,
                dot: true,
            });
            files.forEach(indexFile => {
                assetAliases[path_1.dirname(indexFile)] = indexFile;
            });
        });
        this.writeFileSync(path_1.join(this.layer0Dir, constants_1.LAYER0_ASSET_ALIASES_FILE), JSON.stringify(assetAliases, null, '  '));
        process.stdout.write('done.\n');
    }
    /**
     * Ensures all assets in the "all", "js", and "ts" subdirectories of `defaultAppPath` are either already
     * present in the user's app or are copied over from `defaultAppPath`.
     * @param defaultAppPath
     * @return A self reference, suitable for chaining
     */
    addDefaultAppResources(defaultAppPath) {
        const addResources = (fromPath) => {
            for (let file of globby_1.default.sync('**/*', {
                cwd: fromPath,
            })) {
                if (!fs_extra_1.existsSync(path_1.join(this.appDir, file))) {
                    console.log(`> ${chalk_1.default.green(file)} not found, creating...`);
                    this.copySync(path_1.join(fromPath, file), path_1.join(this.appDir, file));
                }
            }
        };
        addResources(path_1.join(defaultAppPath, 'all'));
        if (fs_extra_1.existsSync(path_1.join(process.cwd(), 'tsconfig.json'))) {
            addResources(path_1.join(defaultAppPath, 'ts'));
        }
        else {
            addResources(path_1.join(defaultAppPath, 'js'));
        }
        return this;
    }
    /**
     * Copies all the layer0 scripts into the package.json file, if they don't already exist.
     * @param scriptsOverride Used to pass framework-specific script overrides
     * @param overrideExisting Set to true to override existing layer0 script elements
     * @return A self reference, suitable for chaining
     */
    addDefaultLayer0Scripts(scriptsOverride = {}, overrideExisting = false) {
        init_1.addToPackageJson({
            scripts: {
                'layer0:dev': 'layer0 dev',
                'layer0:build': 'layer0 build',
                'layer0:deploy': 'layer0 deploy',
                ...scriptsOverride,
            },
        }, overrideExisting);
        console.log(chalk_1.default.bold('\nAdded the following scripts to package.json:\n'));
        console.log(`    ${chalk_1.default.cyan('layer0:dev')} - Simulate your app on Layer0 locally.`);
        console.log(`    ${chalk_1.default.cyan('layer0:build')} - Build your app for deployment on Layer0.`);
        console.log(`    ${chalk_1.default.cyan('layer0:deploy')} - Build and deploy your app on Layer0.`);
        return this;
    }
    /**
     * Copies a file
     * @param from the source path
     * @param to the destination path
     */
    copySync(from, to, copySyncOptions = {}) {
        if (fs_extra_1.existsSync(from)) {
            this.log(`COPY: ${from.replace(this.appDir + '/', '')} -> ${to.replace(this.appDir + '/', '')}`);
            return fs_extra_1.copySync(from, to, copySyncOptions);
        }
        else {
            console.warn(`${chalk_1.default.yellow('Warning:')} The following file/directory path referenced in your Layer0 router configuration does not exist: ${path_1.relative(process.cwd(), from)}. Requests matching this route will return a 404 status.`);
        }
    }
    /**
     * Writes a file
     * @param to the destination path
     * @param content the contents of the file
     * @param encoding the encoding
     */
    writeFileSync(to, content) {
        this.log(`WRITE: ${to.replace(this.appDir + '/', '')}`);
        fs_extra_1.mkdirpSync(path_1.dirname(to));
        return fs_extra_1.writeFileSync(to, content, 'utf8');
    }
    /**
     * Deletes all files in a directory
     * @param dir The directory to empty
     */
    emptyDirSync(dir) {
        this.log(`EMPTY: ${dir.replace(this.appDir + '/', '')}`);
        return fs_extra_1.emptyDirSync(dir);
    }
    /**
     * Reads a file
     * @param path the file path
     * @param options Options for `fs.readFileSync`
     * @returns The file contents
     */
    readFileSync(path, { encoding = 'utf8' } = {}) {
        this.log(`READ: ${path.replace(this.appDir + '/', '')}`);
        return fs_extra_1.readFileSync(path, { encoding });
    }
    /**
     * Deletes a file
     * @param path The file to delete
     */
    removeSync(path) {
        this.log(`DELETE: ${path.replace(this.appDir + '/', '')}`);
        return fs_extra_1.removeSync(path);
    }
    /**
     * Deletes the output of the previous build.
     */
    clearPreviousBuildOutput() {
        // clear .layer0 directory
        this.emptyDirSync(this.layer0Dir);
        return this;
    }
    /**
     * Returns the router instance.
     * @return {Router}
     */
    async getRouter() {
        // this is needed for RouteGroup#dir to find source files to add to the manifest
        source_1.setSourceDir(process.cwd());
        if (!this.router) {
            if (process.env.WEBPACK === 'true') {
                // There is no visualizer for ESBuild's bundle analysis meta file yet, so if the user wants to analyze their
                // router bundle, we need to let them build with webpack
                // To run a build with analysis, the user needs to run: ANALYZE=true WEBPACK=true layer0 build
                // Also, we late-load webpack here since webpack and webpack-bundle-analyzer are peer dependencies that are not
                // required if the user doesn't need to build with webpack.
                await require('./bundle-webpack').default();
            }
            else {
                await bundle_esbuild_1.bundleRouterAndConfig();
            }
            const cwd = process.cwd();
            const routerFile = path_1.basename(config_1.default.get('routes'));
            try {
                process.chdir(this.jsDir);
                this.router = loadRouter_1.default(path_1.join(this.jsDir, routerFile));
            }
            finally {
                process.chdir(cwd);
            }
        }
        return this.router;
    }
    /**
     * Layer0 version of @layer0/core.
     * @type {String}
     */
    static get layer0Version() {
        return (process.env[constants_1.LAYER0_ENV_VARIABLES.versionOverride] ||
            require('../package.json').version.replace(/\+.*/, '')); // remove the suffix added by yalc so that the last deployed lamba is used when testing an unreleased version of Layer0 core
    }
    /**
     * Copies all of the standard assets into the JS and static asset bundles.  These are the same for any framework.
     */
    async build(options) {
        await this.includeFiles();
        await this.includeNodeModules();
        // store the router source so we can show it in console and download for debugging purposes
        const routerPath = path_1.join(this.appDir, config_1.default.get('routes'));
        this.addSource(routerPath);
        // routes.js and layer0.config.js
        const router = await this.getRouter();
        // Add the prod entry point from the connector attribute in layer0.config.js
        if (!(options === null || options === void 0 ? void 0 : options.excludeProdEntryPoint)) {
            await this.addProdEntrypoint();
        }
        // lambda handler
        this.addJSAsset(path_1.join(__dirname, '..', 'lambda', 'handler.js'), 'handler.js');
        this.addJSAsset(path_1.join(__dirname, '..', 'lambda', 'handler.js.map'), 'handler.js.map');
        const configPath = [
            path_1.join(this.appDir, constants_1.LAYER0_CONFIG_FILE),
            path_1.join(this.appDir, constants_1.LAYER0_CONFIG_FILE.replace('.js', '.cjs')),
        ].find(fs_extra_1.existsSync);
        // add layer0.config.js to src
        if (configPath)
            this.addSource(configPath);
        // When run with --sources, add the source code to the build for debugging purposes based on the sources property of layer0.config.js
        if (process.env.LAYER0_INCLUDE_SOURCES === 'true') {
            await this.addSources();
        }
        // Parse router and store result
        const routerInfo = parseRouter_1.default(routerPath);
        this.writeFileSync(path_1.join(this.layer0Dir, 'routerInfo.json'), JSON.stringify({ location: config_1.default.get('routes'), info: routerInfo }, null, 3));
        // s3
        process.env.LAYER0_EDGE_BUILD = 'true';
        const edgeConfig = await router.createEdgeConfig();
        // Copy all serveStatic assets to S3
        for (let destination in edgeConfig.destinations) {
            const { routes, errorRoutes = [] } = edgeConfig.destinations[destination];
            routes
                .concat(errorRoutes)
                .filter(r => r.route &&
                r.route.action === constants_1.ACTIONS.proxy &&
                // @ts-ignore - not happy with r.route potentially undefined here
                [constants_1.BACKENDS.static, constants_1.BACKENDS.permanentStatic].includes(r.route.backend))
                .forEach(r => {
                var _a, _b;
                (_b = (_a = r.route) === null || _a === void 0 ? void 0 : _a.fsPath) === null || _b === void 0 ? void 0 : _b.forEach(fsPath => {
                    // @ts-ignore - not happy with r.route potentially undefined here
                    const { fsExclude: exclude, backend, disableAutoPublish } = r.route;
                    if (!disableAutoPublish) {
                        const permanent = backend === constants_1.BACKENDS.permanentStatic;
                        // File or directory to serve as assets
                        const relativePath = routeToFiles_1.rootDirForPath(fsPath);
                        const absoluteDirPath = path_1.join(process.cwd(), relativePath);
                        const filesToAdd = [];
                        if (fs_extra_1.existsSync(absoluteDirPath) && fs_extra_1.lstatSync(absoluteDirPath).isDirectory()) {
                            // directories
                            const regex = Route_1.default.toRegexp(slash_1.default(fsPath));
                            const files = globby_1.default.sync('**/*', { cwd: path_1.join(process.cwd(), relativePath) });
                            for (let file of files) {
                                const filePath = path_1.join(relativePath, file);
                                if (regex.test(`/${slash_1.default(filePath)}`)) {
                                    // only copy the file to s3 if it can match the route specified in the serveStatic target path (the first parameter)
                                    filesToAdd.push(filePath);
                                }
                            }
                        }
                        else {
                            // individual files
                            filesToAdd.push(relativePath);
                        }
                        this.log(`Adding static assets for route ${r.path}`);
                        for (let file of filesToAdd) {
                            this.addStaticAsset(path_1.join(this.appDir, file), file, { permanent, exclude });
                        }
                    }
                });
            });
        }
        // .layer0/LAYER0_VERSION
        this.writeFileSync(path_1.join(this.layer0Dir, 'LAYER0_VERSION'), DeploymentBuilder.layer0Version);
        // layer0.json is not actually used by anything - we just include it here to make it easier to debug the edge logic so we have easy access to it during development.
        this.writeFileSync(path_1.join(this.layer0Dir, 'layer0.json'), JSON.stringify(edgeConfig, null, '  '));
        this.createStaticAssetAliases();
        process.stdout.write('> Writing static asset manifest... ');
        this.writeStaticAssetManifest(router);
        this.writeStaticAssetExpiration();
        // needed for static asset expiration
        this.addJSAsset(path_1.join(this.layer0Dir, 'static-asset-expiration.json'));
        process.stdout.write('done.\n');
    }
    /**
     * Adds all configured extra files to the lamdba directory
     */
    async includeFiles() {
        if (config_1.default.has('includeFiles')) {
            process.stdout.write('> Copying includeFiles into the bundle... ');
            const globs = config_1.default.get('includeFiles', {});
            for (let key in globs) {
                const relativeDest = globs[key];
                if (relativeDest) {
                    // Per https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows,
                    // Windows paths need to be converted to forward-slashes.
                    const files = globby_1.default.sync(unixify_1.default(path_1.join(this.appDir, key)));
                    for (let src of files) {
                        // if the relativeDest is true, copy it to the same path within the lambda
                        const dest = relativeDest === true
                            ? path_1.relative(this.appDir, src)
                            : path_1.join(relativeDest, path_1.relative(path_1.join(this.appDir, key), src));
                        await this.copySync(src, path_1.join(this.jsDir, dest), { dereference: true });
                    }
                }
            }
            process.stdout.write('done.\n');
        }
    }
    isYarn() {
        return fs_extra_1.existsSync(path_1.join(process.cwd(), 'yarn.lock'));
    }
    /**
     * Adds all dependencies from package.json to the JS bundle (excluding devDependencies)
     */
    async includeNodeModules() {
        if (config_1.default.get('includeNodeModules', false) === true) {
            const args = [];
            const envVars = { ...process.env };
            const yalc = process.env.YALC === 'true';
            let cmd = 'npm'; // default to npm
            let lockFile;
            // Set Env variables for the lambda functions
            envVars['npm_config_target_arch'] = 'x64';
            envVars['npm_config_target_platform'] = 'linux';
            // yarn
            if (this.isYarn()) {
                lockFile = 'yarn.lock';
                cmd = 'yarn';
                if (!yalc) {
                    args.push('install', '--frozen-lockfile');
                }
            }
            else {
                args.push('--target_arch=x64');
                args.push('--target_platform=linux');
                if (fs_extra_1.existsSync(path_1.join(process.cwd(), 'package-lock.json'))) {
                    lockFile = 'package-lock.json';
                    args.push(yalc ? 'install' : 'ci');
                }
                else {
                    args.push('install');
                }
            }
            args.push('--production');
            process.stdout.write('> Adding production dependencies to the bundle... ');
            this.preparePackageJson();
            if (lockFile && !yalc) {
                this.copySync(path_1.join(this.appDir, lockFile), path_1.join(this.jsDir, lockFile));
            }
            await this.exec(`${cmd} ${args.join(' ')}`, { cwd: this.jsDir, env: envVars });
            process.stdout.write('done.\n');
        }
    }
    /**
     * Copies the package.json file into the lambda and adjust all dependencies that
     * use file paths
     */
    preparePackageJson() {
        const dest = path_1.join(this.jsDir, 'package.json');
        this.copySync(path_1.join(this.appDir, 'package.json'), dest);
        const contents = JSON.parse(fs_extra_1.readFileSync(dest, 'utf8'));
        const { dependencies } = contents;
        if (dependencies) {
            for (let name in dependencies) {
                const value = dependencies[name];
                if (value.startsWith('file:')) {
                    // convert file:./path/to/module to file:../../path/to/module
                    const newValue = value.replace(/file:/, `file:..${path_1.sep}..${path_1.sep}`);
                    this.log(`Rewriting ${name}: ${value} => ${newValue}`);
                    dependencies[name] = newValue;
                }
            }
        }
        delete contents.devDependencies;
        fs_extra_1.writeFileSync(dest, JSON.stringify(contents, null, '  '), 'utf8');
    }
    /**
     * Configures the TTL for a static asset. Once the TTL has expired, it will be refreshed
     * by forwarding requests for that asset to serverless.
     * @param path The path to the asset within the app
     * @param maxAgeSeconds The TTL in seconds
     * @return A self-reference, suitable for chaining
     */
    setStaticAssetExpiration(path, maxAgeSeconds, staleWhileRevalidateSeconds) {
        this.assetExpiration[path] = {
            maxAgeSeconds,
            staleWhileRevalidateSeconds,
        };
        return this;
    }
    /**
     * Write the manifest for that tells us what static asset routes to configure in the cloud
     * @param router
     */
    writeStaticAssetManifest(router) {
        this.writeFileSync(path_1.join(this.jsDir, RouteGroup_1.STATIC_ASSET_MANIFEST_FILE), JSON.stringify(router.getStaticAssetManifest(), null, '  '));
    }
    /**
     * Writes static asset expiration times so that we can configure them on S3
     */
    writeStaticAssetExpiration() {
        this.writeFileSync(path_1.join(this.layer0Dir, 'static-asset-expiration.json'), JSON.stringify(this.assetExpiration, null, '  '));
    }
    /**
     * Deletes all .map files from specified folder
     */
    deleteMapFiles(dir) {
        const mapFiles = globby_1.default.sync('**/*.map', {
            onlyFiles: true,
            cwd: dir,
        });
        mapFiles.forEach(file => {
            this.removeSync(path_1.join(dir, file));
        });
    }
}
exports.default = DeploymentBuilder;
