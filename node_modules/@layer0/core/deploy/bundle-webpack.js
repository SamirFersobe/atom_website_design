"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = __importDefault(require("../config"));
const webpack_1 = __importDefault(require("webpack"));
const path_1 = require("path");
const paths_1 = require("./paths");
const resolveInPackage_1 = __importDefault(require("./resolveInPackage"));
const fs_1 = require("fs");
const logo_1 = __importDefault(require("../utils/logo"));
// compatible type definitions are not yet available for this after updating to webpack 5
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const destDir = path_1.join(process.cwd(), paths_1.JS_DIR);
/**
 * Compiles the router and layer0.config.js in production mode.
 * Returns a promise that resolves to the router.
 */
async function bundle() {
    var _a;
    // Use process.stdout.write to be able to concatenate `done.` to the same output line.
    process.stdout.write(`> Bundling ${logo_1.default} router... `);
    const webpackConfig = createConfig({ mode: 'production' });
    const webpackStats = await new Promise((resolve, reject) => {
        webpack_1.default(webpackConfig, (err, stats) => (err ? reject(err) : resolve(stats)));
    });
    const compilationErrors = (_a = webpackStats === null || webpackStats === void 0 ? void 0 : webpackStats.compilation) === null || _a === void 0 ? void 0 : _a.errors;
    if (compilationErrors === null || compilationErrors === void 0 ? void 0 : compilationErrors.length) {
        console.error('Errors occurred while bundling your router:', compilationErrors);
        throw new Error('Bundling router failed.');
    }
    process.stdout.write('done.\n');
}
exports.default = bundle;
/**
 * Creates a webpack compiler for bundling the router in development.
 * @private
 */
function createCompiler() {
    return webpack_1.default(createConfig());
}
exports.createCompiler = createCompiler;
/**
 * Creates a webpack config for bundling the router
 * @private
 */
function createConfig(webpackConfig) {
    const routesPath = path_1.join(process.cwd(), config_1.default.get('routes'));
    const configPath = [
        path_1.join(process.cwd(), 'layer0.config.js'),
        path_1.join(process.cwd(), 'layer0.config.cjs'),
    ].find(fs_1.existsSync);
    if (!configPath) {
        throw new Error('layer0.config.js not found. Run "layer0 init" to create this file.');
    }
    const rules = [];
    try {
        // skip ts-loader if typescript is not installed in the project
        require.resolve('typescript');
        rules.push({
            test: /\.ts$/,
            use: [
                {
                    loader: resolveInPackage_1.default('ts-loader'),
                    options: {
                        onlyCompileBundledFiles: true,
                        compilerOptions: {
                            noEmit: false,
                        },
                    },
                },
            ],
            exclude: /node_modules/,
        });
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    try {
        // skip babel-loader if babel is not installed in the project
        require.resolve('@babel/core');
        rules.push({
            test: /\.js$/,
            use: resolveInPackage_1.default('babel-loader'),
            exclude: /node_modules/,
        });
        // eslint-disable-next-line no-empty
    }
    catch (e) { }
    const plugins = [];
    if (process.env.ANALYZE === 'true') {
        plugins.push(new BundleAnalyzerPlugin({
            analyzerMode: 'static',
            reportFilename: '../bundle-analysis.html',
        }));
    }
    return {
        stats: 'errors-warnings',
        devtool: process.env.NODE_ENV === 'production' ? false : 'cheap-module-source-map',
        entry: {
            routes: routesPath,
            'layer0.config': configPath,
        },
        optimization: {
            // This prevents webpack from string replacing process.env.NODE_ENV, which has been found to cause trouble on the server
            // For example, without this, process.env.NODE_ENV doesn't have the correct value in the user's routes file.
            nodeEnv: false,
        },
        output: {
            path: destDir,
            libraryTarget: 'umd',
        },
        module: {
            rules,
        },
        resolve: {
            extensions: ['.ts', '.js'],
        },
        externals: {
            chalk: 'chalk',
        },
        target: 'node',
        mode: 'development',
        ...webpackConfig,
        plugins: [...plugins, ...((webpackConfig === null || webpackConfig === void 0 ? void 0 : webpackConfig.plugins) || [])],
    };
}
