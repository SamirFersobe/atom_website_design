"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bindParamsToPath_1 = __importDefault(require("./bindParamsToPath"));
const path_to_regexp_1 = require("path-to-regexp");
/**
 * Replaces named parameters in the specified path with back references so
 * that the edge can create a path using the matched params with a regex replace in VCL.
 *
 * **Note** this method can return a replacement that, when applied, can result in duplicated '/' characters,
 * which must be collapsed.  For example, if the route pattern is /:locale?/products and the url is '/products',
 * where the optional parameter is not provided, url.replace(pattern, replacement) will result in '//products'
 *
 * @param matcher A route-parser route
 * @param path The request path
 * @returns A path with params replaced by back references
 */
function convertParamsToBackReferences(source, dest) {
    if (source == null)
        return dest;
    const sourceTokens = getBackReferences(source);
    return bindParamsToPath_1.default(dest, sourceTokens);
}
exports.default = convertParamsToBackReferences;
function getBackReferences(path) {
    if (!path)
        return {};
    // In case path is an absolute path
    const absolutePathMatch = path.match(/https?:\/\/[^/]+(.*)/);
    if (absolutePathMatch) {
        path = `/${absolutePathMatch[1]}`;
    }
    // Back reference counting starts from 1
    let backReferenceCounter = 1;
    const references = {};
    path_to_regexp_1.parse(path).forEach(token => {
        if (typeof token !== 'string') {
            references[token.name] = `\\${backReferenceCounter++}`;
        }
    });
    return references;
}
exports.getBackReferences = getBackReferences;
