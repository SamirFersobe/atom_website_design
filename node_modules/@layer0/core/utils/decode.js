"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = require("zlib");
const constants_1 = require("../constants");
/**
 * If needed decodes the body in place from the response content-encoding.
 * Removes the content-encoding header and updates the content-length as the
 * decoded body has no encoding and will have a different length.
 * @param response
 * @returns True if decoding happened or wasn't needed, false otherwise
 */
function decode(response) {
    var _a;
    const contentEncoding = (_a = response.getHeader(constants_1.HTTP_HEADERS.contentEncoding)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    // When there is no encoding, then there is nothing to decode.
    if (!contentEncoding) {
        return true;
    }
    switch (contentEncoding) {
        case constants_1.GZIP_ENCODING: {
            if (!Buffer.isBuffer(response.body)) {
                return false;
            }
            response.body = zlib_1.gunzipSync(response.body);
            response.removeHeader(constants_1.HTTP_HEADERS.contentEncoding);
            response.setHeader(constants_1.HTTP_HEADERS.contentLength, Buffer.byteLength(response.body));
            return true;
        }
        case constants_1.BROTLI_ENCODING: {
            if (!Buffer.isBuffer(response.body)) {
                return false;
            }
            response.body = zlib_1.brotliDecompressSync(response.body);
            response.removeHeader(constants_1.HTTP_HEADERS.contentEncoding);
            response.setHeader(constants_1.HTTP_HEADERS.contentLength, Buffer.byteLength(response.body));
            return true;
        }
        default: {
            // We cannot decode the body for unsupported encodings.
            return false;
        }
    }
}
exports.default = decode;
