"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const constants_1 = require("../constants");
const environment_1 = require("../environment");
const nonWebpackRequire_1 = __importDefault(require("./nonWebpackRequire"));
// config.backends[x] domainOrIp schema
const domainOrIpSchema = {
    $id: '/domainOrIpSchema',
    type: 'string',
};
// config.backends[x] object schema
const backendObjectSchema = {
    $id: '/backendObjectSchema',
    type: 'object',
    properties: {
        domainOrIp: {
            $ref: domainOrIpSchema.$id,
        },
        port: {
            type: 'number',
            // We allow all ports but we will always use HTTPS protocol no matter the port.
            minimum: 1,
            maximum: 65535,
        },
        hostHeader: {
            type: 'string',
        },
        disableCheckCert: {
            type: 'boolean',
        },
        firstByteTimeout: {
            type: 'number',
        },
        basePath: {
            type: 'string',
        },
    },
    additionalProperties: false,
    required: ['domainOrIp'],
};
// config.backends schema
const backendSchema = {
    $id: '/backendSchema',
    type: 'object',
    patternProperties: {
        '^.*$': {
            oneOf: [{ $ref: domainOrIpSchema.$id }, { $ref: backendObjectSchema.$id }],
        },
    },
};
// layer0.config.js schema
const layer0FileConfigurationSchema = {
    $id: '/layer0FileConfigurationSchema',
    type: 'object',
    properties: {
        name: { type: 'string' },
        team: { type: 'string' },
        prerenderConcurrency: { type: 'number' },
        production: { type: 'boolean' },
        routes: { type: 'string' },
        server: {
            type: 'object',
            required: ['path'],
            properties: { path: { type: 'string' }, export: { type: 'string' } },
        },
        includeFiles: {
            type: 'object',
        },
        sources: {
            type: 'array',
            items: {
                type: 'string',
            },
        },
        backends: {
            $ref: backendSchema.$id,
        },
        includeNodeModules: { type: 'boolean' },
        connector: {
            type: 'string',
        },
    },
    additionalProperties: false,
    required: [],
};
/**
 * An object used to validate an layer0 config.
 *
 * Example:
 * ```js
 * Validator.validateLayer0FileConfiguration(config)
 * ```
 */
class Validator {
    /**
     * Validates `layer0.config.js`. If the config is validated, it is returned; otherwise,
     * an error is thrown.
     * @param config Loaded layer0 configuration
     * @returns The validated config
     */
    static validateLayer0FileConfiguration(config) {
        if (environment_1.isCloud())
            return config;
        // Ajv is really big, so we don't bother validating in the cloud - I've we've gotten this far, let 'er rip, baby!
        const Ajv = nonWebpackRequire_1.default('ajv');
        if (config.connector) {
            try {
                const configSchema = require(`${config.connector}/configSchema`);
                // If a configuration schema exists for the connector, merge into the default schema
                Object.assign(layer0FileConfigurationSchema.properties, configSchema);
            }
            catch {
                // No config schema for connector, nothing to do here
            }
        }
        const ajv = new Ajv({
            allErrors: true,
            schemas: [
                layer0FileConfigurationSchema,
                backendSchema,
                backendObjectSchema,
                domainOrIpSchema,
            ],
        });
        let errors = [];
        // the type cast on the following line is needed to get coverage to 100%.  In theory getSchema can return undefined, but it won't since we are creating the schema ourselves.
        const layer0SchemaValidator = ajv.getSchema(layer0FileConfigurationSchema.$id);
        if (config.backends && config.backends.moov != null) {
            // Don't allow providing moov backend in layer0.config.js
            errors.push({
                message: 'is a reserved backend name',
                // eslint-disable-next-line quotes
                dataPath: ".backends['moov']",
            });
        }
        // Don't allow providing static backend in layer0.config.js
        if (config.backends && config.backends[constants_1.BACKENDS.static]) {
            errors.push({
                message: 'is a reserved backend name',
                // eslint-disable-next-line quotes
                dataPath: `.backends.${constants_1.BACKENDS.static}`,
            });
        }
        // Don't allow providing js backend in layer0.config.js
        if (config.backends && config.backends[constants_1.BACKENDS.js]) {
            errors.push({
                message: 'is a reserved backend name',
                // eslint-disable-next-line quotes
                dataPath: `.backends.${constants_1.BACKENDS.js}`,
            });
        }
        // Run schema validation
        if (!layer0SchemaValidator(config) && layer0SchemaValidator.errors) {
            errors = [...errors, ...layer0SchemaValidator.errors];
        }
        // If errors length is not 0 throw error
        if (errors.length) {
            const errorsString = errors
                .map((err, i) => {
                let eString = `${i + 1}) config${err.dataPath}: ${err.message}`;
                // @ts-ignore
                if (err.keyword === 'additionalProperties') {
                    // @ts-ignore
                    eString += ` '${err.params.additionalProperty}'`;
                }
                return eString;
            })
                .join(os_1.EOL);
            throw new Error(`Layer0 configuration validation failed with errors: ${os_1.EOL}${errorsString}`);
        }
        return config;
    }
}
exports.default = Validator;
