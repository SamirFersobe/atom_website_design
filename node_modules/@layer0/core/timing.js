"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
const context_1 = require("./context");
exports.NOT_ENDED_VALUE = 'na';
class InternalTiming {
    /**
     * @param name The name of the timing component that will be reported in the `x-0-user-t` header
     */
    constructor(name, internal = true) {
        /**
         * The number of milliseconds elapsed
         */
        this.duration = 0;
        /**
         * Set to true if the timing has been ended
         */
        this.ended = false;
        this.name = name;
        const timings = internal ? internalTimings() : userTimings();
        timings.push(this);
    }
    /**
     * Starts the timing.
     * @returns A self-reference, suitable for chaining
     */
    start() {
        this.startTime = new Date();
        this.ended = false;
        return this;
    }
    /**
     * Sets the discrete value for this timing
     * @param discreteValue
     * @returns A self-reference, suitable for chaining
     */
    set(discreteValue) {
        this.discreteValue = discreteValue;
        return this;
    }
    /**
     * Ends the timing.
     * @returns A self-reference, suitable for chaining
     */
    end() {
        if (!this.startTime) {
            console.warn(`Timing ${this.name} not started.`);
            return this;
        }
        this.ended = true;
        this.duration += new Date().getTime() - this.startTime.getTime();
        return this;
    }
    /**
     * Convenience method that is the same as `end`, but meant to indicate
     * that the timing may be resumed later
     */
    pause() {
        return this.end();
    }
    /**
     * Convenience method that is the same as `start`, but meant to indicate
     * that the timing has been paused.
     */
    resume() {
        return this.start();
    }
    /**
     * Gets the value of the timing for response headers. Will be 'na' if not started, otherwise
     * the numeric duration in milliseconds.
     */
    get value() {
        if (this.discreteValue != null) {
            return this.discreteValue;
        }
        else {
            return this.ended ? this.duration : exports.NOT_ENDED_VALUE;
        }
    }
}
exports.InternalTiming = InternalTiming;
/**
 * A higher order function that wraps the provided function in a request context with user
 * and internal timings reset
 * @private
 * @param handler
 */
function withTimings(handler) {
    return (...args) => {
        return context_1.withContext(() => {
            return handler(...args);
        });
    };
}
exports.withTimings = withTimings;
/**
 * Returns the value of the internal timing with the specified name
 * @private
 * @param name The name of an internal timing, for example "ecc"
 */
function getInternalTiming(name) {
    var _a;
    return (_a = internalTimings().find(t => t.name === name)) === null || _a === void 0 ? void 0 : _a.value;
}
exports.getInternalTiming = getInternalTiming;
/**
 * Returns the internal timings from the current request context
 * @private
 */
function internalTimings() {
    return context_1.get('internalTimings', []);
}
/**
 * Returns the user timings from the current request context
 * @private
 */
function userTimings() {
    return context_1.get('userTimings', []);
}
/**
 * Adds x-0-t, x-0-user-t, and server-timing headers to the response
 * @private
 * @param response
 */
function addTimings(response) {
    const userT = userTimings();
    const internalT = internalTimings();
    if (userT.length) {
        response.setHeader(constants_1.HTTP_HEADERS.x0UserT, getTimingsResponseHeader(userT));
        response.setHeader(constants_1.HTTP_HEADERS.serverTiming, appendServerTimings(response));
    }
    if (internalT.length) {
        response.setHeader(constants_1.HTTP_HEADERS.x0T, getTimingsResponseHeader(internalT));
    }
}
exports.addTimings = addTimings;
/**
 * Gets the value of the x-0-user-t header.
 * @private
 */
function getTimingsResponseHeader(timings) {
    return timings.map(t => `${t.name}=${t.value}`).join(',');
}
/**
 * Returns the user timings in server-timing response header format
 * @private
 */
function appendServerTimings(response) {
    const existingHeader = response.getHeader(constants_1.HTTP_HEADERS.serverTiming);
    const timings = userTimings().map(t => `${t.name};dur=${t.value}`);
    if (Array.isArray(existingHeader)) {
        timings.push(...existingHeader);
    }
    else if (existingHeader) {
        timings.push(existingHeader);
    }
    return timings.join(', ');
}
/**
 * Allows you to track the performance of your code and asynchronous operations such as fetches.
 * Timings will be returned as a comma delimited list in the `x-0-user-t` header.
 *
 * ** Example **
 *
 * ```js
 * import Timing from '@layer0/core/timing'
 *
 * const timing = new Timing('fetch').start()
 * const result = await fetch('http://my-api.com/products/1')
 * timing.end() // will result in `x-0-user-t: fetch=(millis)` response header
 * ```
 *
 * If a timing is started but not finished by the time the response is sent, the value will be `na`.
 */
class Timing extends InternalTiming {
    constructor(name) {
        super(name, false);
    }
}
exports.default = Timing;
/**
 * Names for x-0-t components
 */
var InternalNames;
(function (InternalNames) {
    InternalNames["edgeCache"] = "ecc";
    InternalNames["transformRequest"] = "wa";
    InternalNames["transformResponse"] = "wz";
    InternalNames["routeMatching"] = "wr";
    InternalNames["proxying"] = "wp";
})(InternalNames = exports.InternalNames || (exports.InternalNames = {}));
/**
 * Values for edgeCache component of x-0-t
 */
var CacheValue;
(function (CacheValue) {
    CacheValue["hit"] = "hit";
    CacheValue["pass"] = "pass";
    CacheValue["cached"] = "cached";
})(CacheValue = exports.CacheValue || (exports.CacheValue = {}));
