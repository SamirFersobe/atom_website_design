"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const crypto_1 = __importDefault(require("crypto"));
/**
 * An actual cache key derived from a request per the user's CustomCacheKey specification
 */
class CacheKey {
    constructor(request, customKey) {
        var _a;
        this.cookies = {};
        const { host } = request.headers;
        this.body = request.body;
        this.method = (_a = request.method) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        this.query = this.excludeLayer0QueryParams(request.query || {});
        this.pathname = new URL(request.url, `http://${host}`).pathname;
        this.headers = this.getDefaultHeaders(request.headers);
        if (customKey) {
            for (let action of customKey.getActions()) {
                action(this, request);
            }
        }
    }
    static create(request, customKey) {
        return new CacheKey(request, customKey);
    }
    /**
     * We always ignore layer0_* query params when computing the cache key so that things like layer0_prefetch don't cache bust
     * @param query
     */
    excludeLayer0QueryParams(query) {
        const result = {};
        for (let name in query) {
            if (!name.startsWith('layer0_')) {
                result[name] = query[name];
            }
        }
        return result;
    }
    /**
     * Returns an array of values in the object sorted by the key
     * We sort query params so that different orderings will result in a hit
     * @param source Any object of key/value pairs, e.g. query, headers, cookies, etc...
     */
    toSortedArray(source) {
        return Object.keys(source)
            .sort()
            .map(key => [key, source[key]]);
    }
    /**
     * Returns the values of the request headers that are by default included in the caching key
     *
     * Notes:
     * - Cache hash calculation has a connascence of algorithm with VCL moov_hash subroutine so if you
     * are modifying it in any way, you have to modify VCL code generator in the same way. When in doubt
     * the VCL cache hash calculation takes precendence as it is designed to serve production traffic
     * and has been battle tested to do so reliably.
     * - VCL cache hash includes some request/service properties that do no apply in local development:
     * * build number does not exist for local development
     * * flush timestamps for gradual flushing do not apply locally
     */
    getDefaultHeaders(headers) {
        return {
            [constants_1.HTTP_HEADERS.host]: headers[constants_1.HTTP_HEADERS.host],
            [constants_1.HTTP_HEADERS.acceptEncoding]: headers[constants_1.HTTP_HEADERS.acceptEncoding],
            [constants_1.HTTP_HEADERS.x0Destination]: headers[constants_1.HTTP_HEADERS.x0Destination],
            [constants_1.HTTP_HEADERS.x0Protocol]: headers[constants_1.HTTP_HEADERS.x0Protocol],
        };
    }
    toString() {
        return JSON.stringify({
            pathname: this.pathname,
            method: this.method,
            query: this.toSortedArray(this.query),
            body: hash(this.body),
            headers: this.toSortedArray(this.headers),
            cookies: this.toSortedArray(this.cookies),
        });
    }
}
exports.default = CacheKey;
/**
 * Returns the sha256 hash of the provided string as hex
 * @param data The data to hash
 */
function hash(data) {
    if (!data)
        return null;
    const hash = crypto_1.default.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
}
