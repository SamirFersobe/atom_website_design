"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const lru_cache_1 = __importDefault(require("lru-cache"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
let cache;
/**
 * Must have the LAYER0_CACHE environment variable set.
 */
function isCacheEnabled() {
    return process.env.LAYER0_CACHE === 'true';
}
exports.isCacheEnabled = isCacheEnabled;
/**
 * Gets the singleton instance of the development response cache
 */
function getCache() {
    if (!cache) {
        cache = new lru_cache_1.default();
    }
    return cache;
}
exports.getCache = getCache;
/**
 * Evicts all entries from the cache
 */
function clearCache() {
    getCache().reset();
}
exports.clearCache = clearCache;
/**
 * Returns the cached response for the specified key
 * @param key The cache key
 */
function getCachedResponse(key) {
    return getCache().get(key.toString());
}
exports.getCachedResponse = getCachedResponse;
/**
 * Writes the response to the cache if x-0-cache-control has a non-zero max-age value.
 */
function maybeCacheResponse({ response, cacheKey, context }) {
    var _a;
    const method = (_a = cacheKey.method) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (method && !constants_1.CACHEABLE_METHODS.has(method) && context.cacheRouteMethod !== method) {
        // POSTs should only be cached when the route explicitly defines the method criteria as POST
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.method);
        return false;
    }
    else if (cacheKey.body && Buffer.from(cacheKey.body, 'utf8').length > 8000) {
        // here we ensure that we're counting bytes by reading the string as utf8, which is a single byte per character
        // The 8000 character limit is the maximum size fastly can read from the request body
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.bodyTooBig);
        return false;
    }
    else if (response.statusCode && response.statusCode >= 400) {
        // we don't cache statuses 400 and above
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.code);
        return false;
    }
    else if (response.getHeader(constants_1.HTTP_HEADERS.setCookie)) {
        // we don't cache responses with set-cookie headers as they may contain personal data
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.setCookie);
        return false;
    }
    const cacheParams = getCacheParams(response);
    if (cacheParams.private && !context.forcePrivateCaching) {
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.private);
        return false;
    }
    else if (cacheParams.maxAge) {
        getCache().set(cacheKey.toString(), convertToCachedResponse(response), cacheParams.maxAge * 1000);
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.ok);
        return true;
    }
    else {
        response.setHeader(constants_1.HTTP_HEADERS.x0CachingStatus, constants_1.CACHING_STATUS.noMaxAge);
        return false;
    }
}
exports.maybeCacheResponse = maybeCacheResponse;
/**
 * We have to deep clone parts of the
 * @param response HTTP response that we are caching
 */
function convertToCachedResponse(response) {
    return {
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        headers: lodash_clonedeep_1.default(response.getHeaders()),
        body: response.body,
    };
}
/**
 * Gets the effective caching settings for the response
 * @param response The current response
 */
function getCacheParams(response) {
    const defaults = {
        private: false,
        maxAge: 0,
    };
    return {
        ...defaults,
        ...getCacheParamsFromHeader(response.getHeader(constants_1.HTTP_HEADERS.cacheControl)),
        ...getCacheParamsFromHeader(response.getHeader(constants_1.HTTP_HEADERS.x0CacheControl)),
    };
}
/**
 * Extracts private and max-age/s-maxage from a cache-control header
 * @param cacheControl
 */
function getCacheParamsFromHeader(cacheControl) {
    const result = {};
    if (cacheControl) {
        if (!Array.isArray(cacheControl)) {
            cacheControl = [cacheControl];
        }
        const values = {};
        for (let header of cacheControl) {
            const pairs = header.split(/,\s*/).map(v => v.split(/=/));
            for (let [name, value] of pairs) {
                if (name && value) {
                    values[name.toLowerCase()] = value;
                }
                if (name.toLowerCase() === 'private') {
                    // private has no value
                    result.private = true;
                }
            }
            result.maxAge = parseInt(values['s-maxage'] || values['max-age'] || '0');
        }
    }
    return result;
}
