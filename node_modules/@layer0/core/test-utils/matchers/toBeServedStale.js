"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const getMessage_1 = __importDefault(require("../utils/getMessage"));
/**
 * Matches the edge cache-control header for `stale-while-revalidate` in the
 * response with an optional duration
 *
 * **Example**
 * ```js
 * expect(response).toBeServedStale()
 * ...
 * expect(response).toBeServedStale(60*60*24)
 * ```
 *
 * @param {MockResponse} received The mocked response
 * @param {Number} duration Optional - the duration (in seconds) the response is expected to be stale for
 * @returns
 */
function toBeServedStale(received, duration) {
    const response = received;
    const request = response.request;
    const header = response.getHeader(constants_1.HTTP_HEADERS.x0CacheControl);
    const swrName = 'stale-while-revalidate';
    const hasDuration = typeof duration !== 'undefined';
    let pass = !!header, label, message;
    if (header) {
        if (!hasDuration) {
            pass = new RegExp(`${swrName}`).test(header);
            label = 'toBeServedStale';
            message = `'${request.path}' [[to]] be served stale`;
        }
        else {
            pass = new RegExp(`${swrName}=${duration}`).test(header);
            label = 'toBeServedStaleFor';
            message = `'${request.path}' [[to]] be served stale for ${duration}s`;
        }
    }
    return {
        message: () => getMessage_1.default(
        // @ts-ignore
        this, label, message, header),
        pass,
    };
}
exports.toBeServedStale = toBeServedStale;
exports.toBeServedStaleFor = toBeServedStale;
