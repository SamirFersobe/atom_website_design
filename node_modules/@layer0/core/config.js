"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const get_1 = __importDefault(require("./utils/get"));
const has_1 = __importDefault(require("./utils/has"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const fs_1 = require("fs");
const path_1 = require("path");
const constants_1 = require("./constants");
const Validator_1 = __importDefault(require("./utils/Validator"));
const nonWebpackRequire_1 = __importDefault(require("./utils/nonWebpackRequire"));
/**
 * An object containing the config settings. This class is internal, but an instance
 * can be obtained using.
 *
 * ```js
 * import config from '@layer0/core/config'
 * ```
 *
 * @internal
 */
class Config {
    constructor() {
        this.defaults = {
            production: true,
            backends: {},
            includeNodeModules: false,
            routes: ['routes.js', 'routes.ts', 'routes.cjs'].find(file => fs_1.existsSync(path_1.join(process.cwd(), file))) || 'routes.js',
        };
    }
    /**
     * Get configuration by key. Will throw an error if no value is configured
     * @param key The key to grab from the config.
     * @param fallback A value to return if a value is not configured
     */
    get(key, fallback) {
        if (this.has(key)) {
            return get_1.default(this.values, key);
        }
        else if (typeof fallback !== 'undefined') {
            return fallback;
        }
        else {
            throw new Error(`Layer0 configuration key: "${key}" is not defined`);
        }
    }
    /**
     * Returns true if a value has been configured for a specific key, otherwise false.
     * @param key The key to test.
     */
    has(key) {
        if (!this.values)
            this.loadLayer0Config();
        return has_1.default(this.values, key);
    }
    /**
     * Returns all config values
     */
    get all() {
        if (!this.values)
            this.loadLayer0Config();
        return this.values;
    }
    /**
     * Loads Layer0 config and sets the current configuration.
     */
    loadLayer0Config() {
        const file = this.loadFromFile();
        const env = this.loadFromEnv();
        this.values = deepmerge_1.default.all([{}, this.defaults, file, env]);
    }
    /**
     * Load configuration from file
     * @private
     */
    loadFromFile() {
        const configAbsPath = [
            path_1.join(process.cwd(), constants_1.LAYER0_CONFIG_FILE),
            path_1.join(process.cwd(), constants_1.LAYER0_CONFIG_FILE.replace('.js', '.cjs')),
        ].find(fs_1.existsSync);
        if (configAbsPath) {
            try {
                const fileConfig = nonWebpackRequire_1.default(configAbsPath);
                return Validator_1.default.validateLayer0FileConfiguration(fileConfig);
            }
            catch (e) {
                throw new Error(`Failed to load ${configAbsPath}: ${e.message}`);
            }
        }
        return {};
    }
    /**
     * Load configuration from env var
     * @private
     */
    loadFromEnv() {
        if (process.env[constants_1.LAYER0_ENV_VARIABLES.config]) {
            try {
                return JSON.parse(process.env[constants_1.LAYER0_ENV_VARIABLES.config]);
            }
            catch (e) {
                throw new Error(`Layer0 configuration variable: ${constants_1.LAYER0_ENV_VARIABLES.config}, is not parsable as json`);
            }
        }
        return {};
    }
}
/**
 * Create a Config instance.
 */
exports.default = new Config();
