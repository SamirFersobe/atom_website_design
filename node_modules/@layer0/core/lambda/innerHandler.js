"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* istanbul ignore file */
const constants_1 = require("../constants");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const paths_1 = require("../deploy/paths");
const timing_1 = require("../timing");
const loadRouter_1 = __importDefault(require("../router/loadRouter"));
const nonWebpackRequire_1 = __importDefault(require("../utils/nonWebpackRequire"));
const reqResMapper_1 = __importDefault(require("./reqResMapper"));
const stdStreamsWrapper_1 = __importStar(require("./stdStreamsWrapper"));
const getBodyLoggingData_1 = __importDefault(require("./getBodyLoggingData"));
const lambdaInstance_1 = require("./lambdaInstance");
const config_1 = __importDefault(require("../config"));
const router = loadRouter_1.default('./' + path_1.basename(config_1.default.get('routes')));
/**
 * This is the user lambda entry point
 * @param event A lambda event
 * @param instance The lambda instance
 */
async function handler(event, instance) {
    // We always create a new lambda invocations, for all jobs so that we can accurately
    // identify cold starts.
    const invocation = new lambdaInstance_1.LambdaInvocation(instance);
    invocation.start();
    const driLogger = stdStreamsWrapper_1.deepRequestInspectionLogger(instance);
    // Deployment actions: only for internal usage and is not exposed
    switch (event.action) {
        case 'getEdgeConfig':
            return router.createEdgeConfig();
        case 'getPreloadConfig':
            return withLogging(() => router.createPreloadConfig());
    }
    let req, res, responsePromise;
    try {
        const reqResResult = reqResMapper_1.default(event, invocation, {
            allowReqQueryDuplicates: router.allowReqQueryDuplicates,
        });
        req = reqResResult.req;
        res = reqResResult.res;
        responsePromise = reqResResult.responsePromise;
    }
    catch (e) {
        return withLogging(() => {
            console.log('Failed to parse the event to get request and response data:', e.message, e.stack);
            return {
                body: (Buffer.from('{"error":"Failed to parse the event to get request and response data"}')),
                isBase64Encoded: true,
                statusCode: 530,
                statusMessage: 'Internal Layer0 Error',
                multiValueHeaders: {},
            };
        });
    }
    // Handle web requests.
    return await withLogging(async () => {
        const headers = req.headers || {};
        driLogger.logDownstreamRequestInfo({
            method: req.method,
            path: req.url,
            host: headers['host'],
            headers: headers,
            // We keep the protocol format same as the internal Node format on protocol fields.
            protocol: `${headers['x-0-protocol'] || 'https'}:`,
            ...getBodyLoggingData_1.default(req._rawBodyBase64, req.headers),
        });
        try {
            await ensureAppStarted(3001);
        }
        catch (error) {
            console.error(error);
            throw error;
        }
        timing_1.withTimings(() => router.run(req, res))();
        return responsePromise.then((result) => {
            const headers = res.headers || {};
            driLogger.logDownstreamResponseInfo({
                statusCode: res.statusCode,
                statusMessage: res.statusMessage,
                headers,
                ...getBodyLoggingData_1.default(result.body, res.headers),
            });
            return result;
        });
    }, req, instance);
}
exports.handler = handler;
async function startApp(port) {
    const modulePath = path_1.join(process.cwd(), paths_1.pathForBackend(constants_1.BACKENDS.js));
    if (fs_extra_1.existsSync(modulePath)) {
        let prod = nonWebpackRequire_1.default(modulePath);
        if (prod.default) {
            prod = prod.default;
        }
        // load the prod entry point from the framework integration package
        await prod(port);
        // let the router know where to proxy SSR requests
        router.setBackend(constants_1.BACKENDS.js, {
            domainOrIp: constants_1.JS_BACKEND_HOSTNAME,
            port,
        });
        // let the router know where to proxy image optimizer requests
        router.setBackend(constants_1.BACKENDS.imageOptimizer, {
            domainOrIp: process.env.LAYER0_IMAGE_OPTIMIZER_HOST,
            port: process.env.LAYER0_IMAGE_OPTIMIZER_PORT,
        });
    }
}
/**
 * Starts the user's SSR app if it hasn't already been started
 */
let appStartedPromise;
async function ensureAppStarted(port) {
    if (!appStartedPromise) {
        appStartedPromise = startApp(port);
    }
    return appStartedPromise;
}
// TODO: We need to implement a way to clearly split logs between:
//       1) user code logs that needs to be JSON, flagged with { awsTag: 'userLogs' }
//         and sent to STDOUT to be picked up by Cloudwatch and our Log Streamer
//       2) our internal wrapper exception logs that needs to be forwarded and handled
//         by XBP
//
//  1) is correctly implemented by stdStreamsWrapper, *but* we need to make sure that user code errors
//     cannot be logged to stdoud past `stdStreamsWrapper.disable()` otherwise they would not appear in Log Streamer
//
//  2) https://moovweb.atlassian.net/browse/PC-1766, exception logging and shipping in XBP needs
//     to be reviewed:
//       - some exceptions are escaping (some unhandled promise rejection for example)
//       - XBP is logging all access logs, but should only log exception traces (which should trigger alert)
/**
 * Starts collecting stdout
 * @param req The web request, if we're serving one
 */
function startLogging(req, lambdaInstance) {
    if (process.env.LAYER0_LOCAL !== 'true' || process.env.LAYER0_LOCAL_CONSOLE_WRAP === 'true') {
        // don't enable logging when running in local production mode because it makes debug output harder to read
        stdStreamsWrapper_1.default.enable({
            clientIp: req && req.headers[constants_1.HTTP_HEADERS.x0ClientIp],
            requestId: req && req.headers[constants_1.HTTP_HEADERS.xRequestId],
            wi: lambdaInstance === null || lambdaInstance === void 0 ? void 0 : lambdaInstance.id,
        });
    }
}
/**
 * Stops collecting stdout
 */
function stopLogging() {
    stdStreamsWrapper_1.default.disable();
}
// this allows to call deploy action with streaming enabled. This is meant for internal functions such as getPreloadConfig
// that is called after a deployment being successful. We don't need to wrap the edgeConfig call since it will never be available for the user
// since it runs before the deployment has finished and user has no way to access those logs.
async function withLogging(action, req, lambdaInstance) {
    try {
        startLogging(req, lambdaInstance);
        return await action();
    }
    finally {
        stopLogging();
    }
}
