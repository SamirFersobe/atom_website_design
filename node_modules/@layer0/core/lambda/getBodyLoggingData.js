"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = require("zlib");
const constants_1 = require("../constants");
// We limit the logged body due to CloudWatch 256Kb per line limitation,
// CloudWatch costs and, last but not least, websocket exploding on
// larger sizes.
// Tests have shown that 8Kb length results in responsive UI with enough
// captured information.
const MAX_BODY_LENGTH = 8 * 1024;
function base64encode(str) {
    return Buffer.from(str).toString('base64');
}
// Gets the content encoding value from the given headers, no matter
// what case the header has been passed through.
function getContentEncoding(headers) {
    if (!headers) {
        return undefined;
    }
    let encoding = headers[constants_1.HTTP_HEADERS.contentEncoding];
    if (!encoding) {
        for (let name of Object.keys(headers)) {
            if (name.toLowerCase() === constants_1.HTTP_HEADERS.contentEncoding) {
                encoding = headers[name];
                break;
            }
        }
    }
    if (Array.isArray(encoding)) {
        if (encoding.length) {
            encoding = encoding[0];
        }
        else {
            encoding = undefined;
        }
    }
    return encoding;
}
// For the purposes of HTTP request and response logging we log the body.
// This function returns an object with possibly truncated body, full body
// length and a flag set to true if the body was truncated.
// The object is directly included in the HTTP request logging result.
// This functionn never throws as it is just related to logging and we don't
// want a request to ever fail due to logging issues.
function getBodyLoggingData(rawBody, headers) {
    var _a;
    try {
        if (!rawBody || rawBody.length === 0) {
            return {};
        }
        let body;
        if (typeof rawBody === 'string') {
            body = Buffer.from(rawBody, 'base64');
        }
        else if (Buffer.isBuffer(rawBody)) {
            body = rawBody;
        }
        else if (Array.isArray(rawBody)) {
            body = Buffer.concat(rawBody);
        }
        else {
            // We don't know what we have so the best we can do is return a user visible error.
            return {
                body: base64encode(`Unknown body format: ${typeof rawBody}`),
                // @ts-ignore
                bodyLength: rawBody.length,
                bodyTruncated: true,
            };
        }
        let encoding = (_a = getContentEncoding(headers)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        try {
            switch (encoding) {
                case constants_1.GZIP_ENCODING: {
                    body = zlib_1.gunzipSync(body);
                    break;
                }
                case constants_1.BROTLI_ENCODING: {
                    body = zlib_1.brotliDecompressSync(body);
                    break;
                }
                default: {
                    // Nothing to do.
                }
            }
        }
        catch (e) {
            return {
                body: base64encode(`Error while decompressing the body [${encoding}]: ${e.message}`),
                bodyLength: body.length,
                bodyTruncated: true,
            };
        }
        return {
            body: body.slice(0, MAX_BODY_LENGTH).toString('base64'),
            bodyLength: body.length,
            bodyTruncated: body.length > MAX_BODY_LENGTH,
        };
    }
    catch (e) {
        // istanbul ignore next
        return {
            body: base64encode(`Error while getting body logging data: ${e && e.message}`),
            bodyLength: rawBody.length,
            bodyTruncated: true,
        };
    }
}
exports.default = getBodyLoggingData;
