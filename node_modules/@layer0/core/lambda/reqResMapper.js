"use strict";
/**
 * This file is modified version of: https://github.com/danielcondemarin/serverless-next.js/blob/master/packages/next-aws-lambda/lib/compatLayer.js
 *
 * Mods:
 * - getHeader were only able to read lower case headers, but it was able to set upper case headers as well with writeHead,
 *   so all headers are converted to lowercase now.
 *
 * - Gzippes the response on response end if matches the content-type
 *
 * - Removed variable for base64 support since we always return base64 from the lambdas.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const qs_1 = require("qs");
const uuid_1 = require("uuid");
const adaptResponseEncodingToDownstream_1 = __importDefault(require("./adaptResponseEncodingToDownstream"));
const stream_1 = __importDefault(require("stream"));
const environment_1 = require("../environment");
/**
 * Gets the version of @layer0/core.  For this to work in testing an entry needed
 * to be added to moduleNameMapper in the jest config specifically for package.json
 *
 * Notes:
 * - In this module there are multiple places that need to read Layer0 version.
 * But elegantly and correctly offering a single function to read Layer0 version is hard
 * because these different places are transpiled, bundled and invoked in different
 * contexts. For example, if we try to replace this with reading version from
 * DeploymentBuilder then bundling fails.
 *
 * @return {String}
 */
function getLayer0Version() {
    return process.env[constants_1.LAYER0_ENV_VARIABLES.versionOverride] || require('../../package.json').version;
}
exports.default = (event, invocation, options = {
    allowReqQueryDuplicates: false,
}) => {
    const response = {
        body: Buffer.from(''),
        isBase64Encoded: true,
        statusCode: 200,
        statusMessage: 'OK',
        multiValueHeaders: {},
    };
    let responsePromise;
    const req = new stream_1.default.Readable();
    // we provide url, path, and query (decoded), to match how express works so that development and production environment behave the same
    req.url = event.path;
    req.path = event.path;
    req.query = {};
    req.method = event.httpMethod;
    req.rawHeaders = [];
    req.headers = {};
    if (event.multiValueQueryStringParameters &&
        Object.keys(event.multiValueQueryStringParameters).length) {
        Object.keys(event.multiValueQueryStringParameters).forEach(key => {
            // keep backwards compatibility so that arrays with a single value are
            // converted to just be that value:
            const curVal = event.multiValueQueryStringParameters[key];
            if (Array.isArray(curVal) && curVal.length === 1) {
                event.multiValueQueryStringParameters[key] = curVal[0];
            }
        });
        const qs = qs_1.stringify(event.multiValueQueryStringParameters, {
            indices: !options.allowReqQueryDuplicates,
        });
        req.url += `?${qs}`;
        req.query = qs_1.parse(qs); // we stringify and reparse to ensure that query parameters with a single value are not provided as an array
    }
    const headers = event.multiValueHeaders || {};
    for (const key of Object.keys(headers)) {
        // Compatibility with https://nodejs.org/api/all.html#http_message_rawheaders
        // Header names are not lower-cased to maintain Node compatibility.
        for (const value of headers[key]) {
            req.rawHeaders.push(key);
            req.rawHeaders.push(value);
        }
        // Compatibility with https://nodejs.org/api/all.html#http_message_headers
        // Header names *are* lower-cased to maintain Node compatibility.
        req.headers[key.toLowerCase()] = headers[key].toString();
    }
    req.getHeader = (name) => req.headers[name.toLowerCase()];
    req.getHeaders = () => req.headers;
    req.setHeader = (name, value) => {
        req.headers[name.toLowerCase()] = value;
    };
    req.removeHeader = (name) => {
        delete req.headers[name.toLowerCase()];
    };
    req.connection = {};
    // Capture the downstream `accept-encoding` because compute can modify the `req` object
    // and we need the accept encoding post-user code to compress the response.
    const downstreamAcceptEncoding = req.getHeader(constants_1.HTTP_HEADERS.acceptEncoding);
    // req.secure is ExpressJS extension, set to false only when the app is running locally or the protocol is HTTP
    // (so the default remains HTTPS which has historically been the only protocol we allowed)
    req.secure = !environment_1.isLocal() && req.getHeader(constants_1.HTTP_HEADERS.x0Protocol) !== 'http';
    // Depending on the version req.socket.encrypted is set to true by NodeJS when the protocol is HTTPS.
    req.socket = {
        encrypted: req.secure,
    };
    // Depending on the version req.connection.encrypted is set to true by NodeJS when the protocol is HTTPS.
    req.connection = {
        encrypted: req.secure,
    };
    req.protocol = req.secure ? 'https' : 'http';
    // If the downstream has sent us request ID we use it, otherwise we generate a new one.
    // We have to repeat this code here *and* in Router *and* in XBP *and* in edge because
    // each one of these components may be the first to receive the request:
    // - Router when using `layer0 run`
    // - Handler when using `layer0 run --production`
    // - XBP when making request to cloud
    // - Edge when making request to edge
    let newRequestId;
    if (!req.headers[constants_1.HTTP_HEADERS.xRequestId]) {
        newRequestId = uuid_1.v4();
        req.headers[constants_1.HTTP_HEADERS.xRequestId] = newRequestId;
    }
    const res = new stream_1.default();
    Object.defineProperty(res, 'statusCode', {
        get() {
            return response.statusCode;
        },
        set(statusCode) {
            response.statusCode = statusCode;
        },
    });
    Object.defineProperty(res, 'statusMessage', {
        get() {
            return response.statusMessage;
        },
        set(statusMessage) {
            response.statusMessage = statusMessage;
        },
    });
    res.headers = {};
    res.writeHead = (status, statusMessage, headers) => {
        response.statusCode = status;
        if (typeof statusMessage === 'string') {
            response.statusMessage = statusMessage;
        }
        else {
            if (typeof statusMessage === 'object') {
                headers = statusMessage;
                statusMessage = undefined;
            }
        }
        if (typeof headers === 'object') {
            Object.entries(headers).forEach(([name, value]) => {
                res.setHeader(name, value);
            });
        }
        // If this component has generated the new request ID then
        // it is also responsible for sending it downstream.
        if (newRequestId) {
            res.setHeader(constants_1.HTTP_HEADERS.xRequestId, newRequestId);
        }
    };
    res.write = (chunk) => {
        response.body = Buffer.concat([
            response.body,
            Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk),
        ]);
    };
    res.setHeader = (name, value) => {
        res.headers[name.toLowerCase()] = value;
    };
    res.removeHeader = (name) => {
        delete res.headers[name.toLowerCase()];
    };
    res.getHeader = (name) => {
        return res.headers[name.toLowerCase()];
    };
    res.getHeaders = () => {
        return res.headers;
    };
    const onResEnd = (resolve) => (text) => {
        if (text) {
            res.write(text);
        }
        // Compress the response if needed.
        adaptResponseEncodingToDownstream_1.default(downstreamAcceptEncoding, res, response);
        // We always respond with base64 so that we can serve non-text assets like images.
        response.body = response.body.toString('base64');
        response.multiValueHeaders = res.headers;
        invocation.stop();
        logStatusCode(response);
        logExecutionTime(response, invocation);
        logComponentVersion(response, getLayer0Version(), invocation.lambda.id);
        fixApiGatewayMultipleHeaders();
        resolve(response);
    };
    responsePromise = new Promise(resolve => {
        res.end = onResEnd(resolve);
    });
    if (event.body) {
        // We allow two ways to read the body. One is through stream events and
        // the other is directly on the request object. The 2nd one is used
        // internally by logging. This does not consume additional memory as
        // event.body is alive during the whole lambda lifetime anyways.
        req.push(event.body, event.isBase64Encoded ? 'base64' : undefined);
        req._rawBodyBase64 = event.body;
    }
    req.push(null);
    function fixApiGatewayMultipleHeaders() {
        for (const key of Object.keys(response.multiValueHeaders)) {
            if (!Array.isArray(response.multiValueHeaders[key])) {
                response.multiValueHeaders[key] = [response.multiValueHeaders[key]];
            }
        }
    }
    return { req, res, responsePromise };
};
/**
 * Adds an `x-0-status` header to the response based on the status code.
 *
 * Notes:
 * - If the `x-0-status` already exists then the status is prefixed to upstream value.
 *
 * @param response The response event
 * @private
 */
function logStatusCode(response) {
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.x0Status, `w=${response.statusCode}`);
}
/**
 * Adds an `x-0-t` header to the response based on the current time.
 *
 * Notes:
 * - If the `x-0-t` already exists then the execution time is prefixed to upstream value.
 * - `wt` stands for "worker time", the duration of the current execution
 * - `wc` stands for "worker count", the number of times the lambda has been invoked,
 *   with the first invoication having the count of *1* (same as `pc` counter in XBP)
 * - `wg` stands for "worker age", the number of milliseconds since the lambda instances was spawned
 *   (`wa` already stands for request transformation time)
 * - `wl` stands for "worker lifetime", the total lifetime duration
 *
 * @param response The response event
 * @param startTime The start time of the request
 * @private
 */
function logExecutionTime(response, invocation) {
    const lambda = invocation.lambda;
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.x0T, `wt=${invocation.duration},wc=${lambda.invocationCounter},wg=${lambda.age},wl=${lambda.lifetimeDuration}`);
}
/**
 * Adds an `x-0-components` header to the response based on the current time.
 *
 * Notes:
 * - If the `x-0-components` already exists then the version is prefixed to upstream value.
 * - `w` stands for "worker" and has the Layer0 version of the worker
 * - `wi` stands for "worker id"
 *
 * @param response The response event
 * @param version The Layer0 version of the package
 * @private
 */
function logComponentVersion(response, version, lambdaId) {
    prefixResponseHeader(response, constants_1.HTTP_HEADERS.x0Components, `w=${version},wi=${lambdaId}`);
}
/**
 * Sets the response header to a new value by prefixing it with the given value or,
 * if it doesn't exist, by setting it to the given value,
 *
 * @param response The response event
 * @param headerName The name of the header to prefix or set
 * @param prefixValue The value of the prefix without trailing comma
 * @private
 */
function prefixResponseHeader(response, headerName, prefixValue) {
    const headerValue = response.multiValueHeaders[headerName];
    if (headerValue) {
        if (Array.isArray(headerValue)) {
            headerValue[0] = `${prefixValue},${headerValue[0]}`;
        }
        else {
            response.multiValueHeaders[headerName] = `${prefixValue},${headerValue}`;
        }
    }
    else {
        response.multiValueHeaders[headerName] = `${prefixValue}`;
    }
}
