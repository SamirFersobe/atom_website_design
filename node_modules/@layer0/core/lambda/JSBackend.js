"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tcp_port_used_1 = __importDefault(require("tcp-port-used"));
let started = false;
/**
 * Base class that all framework integration packages should implement to start a
 * server instance of the framework to which requests can be proxied as the __js__ backend.
 */
class JSBackend {
    /**
     * @param port The port to which the server instance should bind.
     */
    constructor(port) {
        this.started = false;
        this.port = port;
    }
    /**
     * Returns true if the provided class extends JSBackend.
     * @param obj A class
     */
    static isSubclass(obj) {
        return obj.__type__ == 'JSBackend';
    }
    /**
     * Starts the app's server build. We don't start the app if the target port is already
     * taken. This will be the case when using layer0 run --serverless to emulate the cloud locally,
     * since serverless-offline sandboxes the app in such a way that it's difficult to keep
     * track of whether or not the app has been started - checking the port is the easiest way -
     * and it will attempt to start the app on every request.
     */
    async start() {
        if (started || (await tcp_port_used_1.default.check(this.port))) {
            return;
        }
        else {
            started = true;
            await this.doStart();
        }
    }
    /**
     * Subclasses must override this method to implement starting the app's server build.
     */
    async doStart() {
        throw new Error('Subclasses must override the doStart method.');
    }
}
exports.default = JSBackend;
JSBackend.__type__ = 'JSBackend';
