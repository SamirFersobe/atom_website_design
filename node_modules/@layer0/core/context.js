"use strict";
/**
 * This module provides a context that can be used to store request
 * state. For example, accumulating timing metrics from various layers
 * during the life of the request.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const environment_1 = require("./environment");
const nonWebpackRequire_1 = __importDefault(require("./utils/nonWebpackRequire"));
const CONTEXT = 'layer0';
let clsNamespace;
/**
 * Runs the specified callback within the specified context
 * @param cb
 */
function withContext(cb) {
    if (environment_1.isLocal()) {
        return createClsNamespace().runAndReturn(cb);
    }
    else {
        global.__layer0_timings__ = new SingletonContext();
        return cb();
    }
}
exports.withContext = withContext;
/**
 * Returns the current context.
 */
function getContext() {
    return global.__layer0_timings__ || getClsNamespace();
}
/**
 * Creates a new CLS-hooked namespace
 */
function createClsNamespace() {
    const cls = nonWebpackRequire_1.default('cls-hooked');
    if (!clsNamespace) {
        clsNamespace = cls.createNamespace(CONTEXT);
    }
    return clsNamespace;
}
/**
 * Gets the current CLS-hooked namespace
 */
function getClsNamespace() {
    return nonWebpackRequire_1.default('cls-hooked').getNamespace(CONTEXT);
}
/**
 * Gets a value from the current context
 * @param key The name of the variable to get
 * @param defaultValue A default value to set and return if no value is found.
 */
function get(key, defaultValue) {
    try {
        const context = getContext();
        let value = context.get(key);
        if (value == null) {
            value = defaultValue;
            context.set(key, defaultValue);
        }
        return value;
    }
    catch (e) {
        return defaultValue;
    }
}
exports.get = get;
/**
 * Sets a value on the current context
 * @param key The variable to set
 * @param value The value to store
 */
function set(key, value) {
    try {
        getContext().set(key, value);
    }
    catch (e) {
        throw new Error('set must be called within withContext');
    }
}
exports.set = set;
/**
 *
 */
class SingletonContext {
    constructor() {
        this.values = {};
    }
    get(key) {
        return this.values[key];
    }
    set(key, value) {
        this.values[key] = value;
    }
}
