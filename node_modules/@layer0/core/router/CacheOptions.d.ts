import CustomCacheKey from './CustomCacheKey';
import { HTTP_METHODS } from '../constants';
export declare type HTTPMethod = keyof typeof HTTP_METHODS;
/**
 * Options for controlling caching behavior in the browser and at the network edge.
 */
export interface CacheOptions {
    /**
     * Sets the caching behavior at edge. When set to `false` the caching in the edge is turned
     * off. This also turns off queueing of potentially cacheable requests that platform performs
     * automatically.
     *
     * Note: if know for sure that a specific `GET` route will never cache then you should
     * always set `edge` caching to `false` for it as it will disable `GET` request coalescing
     * making your application faster.
     */
    edge?: EdgeCacheOptions | false;
    /**
     * Sets the caching behavior in the browser. When set to `false` the caching in the browser
     * is turned off.
     */
    browser?: BrowserCacheOptions | false;
    /**
     * Allows you to split or normalize the cache space for a given route. Common use cases include:
     *
     * - serving multiple variants of the same URL based on a currency and/or language cookie.
     * - caching different responses based on device type
     * - ignoring all but a specific set of query parameters when looking up a response from the cache.
     *
     * **Example**
     *
     * ```js
     *  import { Router, CustomCacheKey } from '@layer0/core/router'
     *
     *  new Router()
     *    .match('/some-path', ({ cache }) => {
     *      cache({
     *        key: new CustomCacheKey()
     *          .excludeAllQueryParametersExcept('color', 'size')
     *          .addCookie('currency')
     *          .addCookie('location', cookie => {
     *            cookie.group('na').byPattern('us|ca')
     *            cookie.group('eur').byPattern('de|fr|ee')
     *          }),
     *        edge: {
     *          maxAgeSeconds: 60 * 60
     *        }
     *      })
     *    })
     * ```
     */
    key?: CustomCacheKey;
    /**
     * If true, prefetch requests that match the route pattern will not be cached directly,
     * but will instead force the Prefetcher to prefetch paths listed in the response's
     * `x-0-upstream-requests` header.
     */
    prefetchUpstreamRequests?: boolean;
}
/**
 * Options for controlling caching behavior at edge
 */
export interface EdgeCacheOptions {
    /**
     * The maximum number of seconds that a response is served from the cache until it is
     * considered stale. Unless `staleWhileRevalidate` is specified, stale responses will
     * not be returned to the browser.
     */
    maxAgeSeconds?: number;
    /**
     * Extends the duration that a response will be served from the cache after it has become stale.
     * When using staleWhileRevalidate, if Layer0 receives a request for a stale asset, the cached
     * response will be served and a fresh response will be concurrently fetch so that it can be served
     * for future requests. The stale response will continue to be served until the fresh fetched.
     */
    staleWhileRevalidateSeconds?: number;
    /**
     * Allows you to force caching of responses marked as `private` in their `cache-control` header.
     * This option must be used with utmost care to avoid leaking private information.
     *
     * **Example**
     *
     * ```js
     *  import { Router, CustomCacheKey } from '@layer0/core/router'
     *
     *  new Router()
     *    .match('/private/path', ({ cache }) => {
     *      cache({
     *        edge: {
     *          maxAgeSeconds: 60 * 60,
     *          key: new CustomCacheKey()
     *            .addCookie('session'),
     *          forcePrivateCaching: true,
     *        }
     *      })
     *    })
     * ```
     */
    forcePrivateCaching?: boolean;
}
/**
 * Options for controlling caching behavior in the browser
 */
export interface BrowserCacheOptions {
    /**
     * Sets the `max-age` value of the `cache-control` header sent to the browser.  This controls the duration
     * that the response is held in the browser's http cache.
     */
    maxAgeSeconds?: number;
    /**
     * Sends an `x-sw-cache-control` header with a value of `max-age={serviceWorkerSeconds}`.  This is not a standard
     * header that service workers understand by default.  You'll need to implement logic to handle this in your service worker.
     */
    serviceWorkerSeconds?: number;
    /**
     * Set to `true` to convert all requests to GETs using the service worker. Doing so
     * allows you to prefetch and cache non-GET requests.  Since all prefetch requests are GETs,
     * setting this config to `true` will ensure that the actual, non-prefetch requests use
     * GET as well and thus have the same cache key as their prefetch counterparts.
     *
     * When `true`, the service worker will add the request body as the `pref_layer0_body` parameter.
     * You can then use a `.get()` route with `transformRequest` to convert the `get` to the original method (`post`, for example)
     * when fetching from the backend.
     *
     * Note that you must specify two routes when using this method: one for the `get` and one for the original method,
     * This is because do not guarantee that the service worker is installed and running by the time requests are sent, so some
     * requests will inevitably sent using their original method and body.
     *
     * **Example**
     *
     * ```js
     *  import { Router } from '@layer0/core/router'
     *  import { transformMethod } from '@layer0/core/transform'
     *
     *  const cacheConfig = {
     *    edge: {
     *      maxAgeSeconds: 60 * 60 * 24,
     *      staleWhileRevalidateSeconds: 60 * 60
     *    },
     *    browser: {
     *      serviceWorkerSeconds: 60 * 60 * 24,
     *      convertToGet: true // convert POSTs to GETs so we can prefetch and cache them
     *    }
     *  }
     *
     *  export default new Router()
     *    // When the request is a GET, convert it to post using serverless compute and cache the result
     *    .get('/some-post-path', (res) => {
     *      cache(cacheConfig)
     *      res.proxy('origin', {
     *        transformRequest: transformMethod('post')
     *      })
     *    })
     *    // When the request is a POST, forward it to origin from the edge without using serverless compute
     *    .post('/some-post-path', ({ cache, proxy }) => {
     *      cache(cacheConfig)
     *      proxy('origin')
     *    })
     * ```
     *
     * @param toMethod The method to to set
     */
    convertToGet?: boolean;
    /**
     * Set to true if the request is for a SPA and there will be prefetch requests made
     * based on the headers of another request
     *
     * @private - Until we ensure that the layer0_head requests are viable
     */
    spa?: boolean;
}
