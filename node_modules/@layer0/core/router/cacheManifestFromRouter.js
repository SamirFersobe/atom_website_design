"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseResponseWriter_1 = require("./BaseResponseWriter");
const CacheManifest_1 = __importDefault(require("./CacheManifest"));
const mapValues_1 = __importDefault(require("../utils/mapValues"));
/**
 * Generates a new `CacheManifest` object from the rules given in the provided `Router`
 */
function cacheManifestFromRouter(router) {
    const manifest = new CacheManifest_1.default();
    const propToString = (regexOrString) => {
        if (regexOrString === undefined)
            return undefined;
        return regexOrString instanceof RegExp ? regexOrString.source : regexOrString;
    };
    for (let route of router.routeGroups.getRoutes()) {
        const writer = new StubWriter();
        // @ts-ignore Typescript doesn't like that we're passing in the base class here -
        // but we keep ResponseWriter on the handler method for documentation purposes
        route.handler(writer);
        const entry = {
            criteriaPath: route.criteria.path,
            route: route.toRegexString(),
            method: propToString(route.criteria.method),
            protocol: propToString(route.criteria.protocol),
            cacheOptions: writer.cacheOptions,
            returnsResponse: writer.returnsResponse,
        };
        if (route.criteria.query) {
            // @ts-ignore The lodash response is a Dictionary which confuses TS
            entry.query = mapValues_1.default(route.criteria.query, (value) => value ? value.source : null);
        }
        // Because service worker cannot match on headers and cookies we ignore them
        // during the creation of cache manifest. This is problematic but it's
        // less problematic than pretending to not ignore them and creating
        // routes that are too "greedy" (they can never match on headers/cookies
        // so overall the condition is always weaker and thus matches more than
        // it should)
        //
        // An example of the issues this causes arises when users try to block some
        // traffic in the router (e.g. from certain countries) The blocking is
        // based on the geo location headers that are injected into the request
        // by the edge so aren't even theoretically available for evaluation
        // in the browser. This leads to service worker matching *all* requests
        // to something that has no caching options (it only has the blocking code)
        // leading to service worker rejecting to cache anything, contrary to what
        // the rest of the router states.
        if (route.criteria.headers || route.criteria.cookies) {
            continue;
        }
        manifest.entries.push(entry);
    }
    return manifest;
}
exports.default = cacheManifestFromRouter;
/**
 * Helper class used to generate manifest entries from a Router
 * @private
 */
class StubWriter extends BaseResponseWriter_1.BaseResponseWriter {
    constructor() {
        super(...arguments);
        this.response = {};
        this.request = {};
        this.cacheOptions = {};
        this.returnsResponse = false;
        this.doesReturnResponse = () => (this.returnsResponse = true);
        this.cache = (options) => {
            this.cacheOptions = options;
        };
        this.send = this.doesReturnResponse;
        this.compute = this.doesReturnResponse;
        this.proxy = this.doesReturnResponse;
        this.redirect = this.doesReturnResponse;
        this.render = this.doesReturnResponse;
        this.serveStatic = this.doesReturnResponse;
        this.serviceWorker = this.doesReturnResponse;
        this.renderWithApp = this.doesReturnResponse;
        this.appShell = this.doesReturnResponse;
        this.stream = this.doesReturnResponse;
    }
}
