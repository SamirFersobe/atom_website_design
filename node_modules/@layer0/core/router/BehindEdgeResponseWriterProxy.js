'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Set of methods that are to be intercepted and made noop
 * outside of the immediate mode (which is in effect only
 * during compute on serverless)
 *
 * @private
 */
const conditionallyExecutedMethods = new Set([
    'cache',
    'setRequestHeader',
    'updateRequestHeader',
    'removeRequestHeader',
    'setResponseHeader',
    'updateResponseHeader',
    'removeResponseHeader',
    'setUpstreamResponseHeader',
    'updateUpstreamResponseHeader',
    'removeUpstreamResponseHeader',
    'addResponseCookie',
    'updateResponseCookie',
    'removeResponseCookie',
    'addUpstreamResponseCookie',
    'updateUpstreamResponseCookie',
    'removeUpstreamResponseCookie',
]);
/**
 * Response writer proxy used then core router is not on the edge.
 *
 * Notes:
 * - We need this to avoid running header and other transformations on
 * both edge and in the cloud. We do this by overriding the ResponseWriter
 * header transformation methods so that they are either a noop when
 * running outside of immediate mode or immediately executing them.
 *
 * @param writer ResponseWriter to which we are proxying the requests
 *
 * @private
 */
const create = (writer) => {
    const wrapComputeConditionedFunction = (target, property) => {
        // We cannot use closures but rather functions so that we can bind them.
        return async function (...args) {
            if (!target.runningImmediately) {
                return;
            }
            return await target[property](...args);
        }.bind(target);
    };
    return new Proxy(writer, {
        get: (target, property) => {
            if (property === 'serveStatic') {
                return wrapServeStatic(target, target.serveStatic);
            }
            else if (conditionallyExecutedMethods.has(property.toString())) {
                return wrapComputeConditionedFunction(target, property);
            }
            else {
                return target[property];
            }
        },
    });
};
exports.default = {
    create,
};
/**
 * Overrides the default behavior of serveStatic when running behind the edge to
 * skip trying to pull the file from S3 and just running the onNotFound function
 * because the edge has already tried and failed to pull the file from S3.
 * @param _path
 * @param options
 */
function wrapServeStatic(res, originalMethod) {
    return async (path, options = {}) => {
        // @ts-ignore We want to leave runningImmediately private
        if (res.runningImmediately) {
            return originalMethod.call(res, path, options);
        }
        else if (options.onNotFound) {
            // @ts-ignore We want to leave runImmediately private
            res.setCreateResponseAction(() => res.runImmediately(() => options.onNotFound(res)));
        }
        else {
            throw new Error('Should not get to serveStatic without onNotFound when running behind the edge.');
        }
    };
}
