"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Groups_1 = __importDefault(require("./Groups"));
const cookie_1 = require("cookie");
exports.CUSTOM_CACHE_KEY_ACTIONS = {
    blacklistAll: 'blacklist-all-query-parameters',
    blacklistSome: 'blacklist-some-query-parameters',
    whitelistSome: 'whitelist-some-query-parameters',
    addValue: 'add-value',
    removeMethod: 'remove-method',
    removeBody: 'remove-body',
};
/**
 * Allows you to split or normalize the cache space for a given route. Common use cases include:
 *
 * - serving multiple variants of the same URL based on a currency and/or language cookie.
 * - caching different responses based on device type
 * - ignoring all but a specific set of query parameters when looking up a response from the cache.
 *
 * **Example**
 *
 * ```js
 *  import { Router, CustomCacheKey } from '@layer0/core/router'
 *
 *  new Router()
 *    .match('/some-path', ({ cache }) => {
 *      cache({
 *        key: new CustomCacheKey()
 *          .excludeAllQueryParametersExcept('color', 'size')
 *          .addCookie('currency')
 *          .addCookie('location', cookie => {
 *            cookie.group('na').byPattern('us|ca')
 *            cookie.group('eur').byPattern('de|fr|ee')
 *          }),
 *        edge: {
 *          maxAgeSeconds: 60 * 60
 *        }
 *      })
 *    })
 * ```
 */
class CustomCacheKey {
    constructor() {
        this.config = [];
        this.actions = [];
    }
    /**
     * Creates a copy of the cache key.
     */
    clone() {
        const newKey = new CustomCacheKey();
        newKey.actions = this.actions;
        newKey.config = this.config;
        return newKey;
    }
    /**
     * Excludes the entire query string from the cache key.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeAllQueryParameters() {
        this.config.push({ action: exports.CUSTOM_CACHE_KEY_ACTIONS.blacklistAll });
        this.actions.push((key, srcRequest) => {
            key.query = {};
        });
        return this;
    }
    /**
     * Excludes the provided query parameters from the cache key.  All other parameters
     * will still be part of the cache key. We also refer to this as "blacklisting" query parameters.
     * @param names The names of the query parameters to blacklist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeQueryParameters(...names) {
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.blacklistSome,
            names,
        });
        this.actions.push((key, srcRequest) => {
            for (let name of names) {
                delete key.query[name];
            }
        });
        return this;
    }
    /**
     * Excludes all query parameters except those provided from the cache key.  We also refer to
     * this as "whitelisting" query parameters.  We recommend using this method over `excludeQueryParameters`
     * as it's difficult to know all of the query parameters your application might receive and unexpected
     * query parameters can lead to significantly lower cache hit rates.
     * @param names The names of the query parameters to whitelist
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    excludeAllQueryParametersExcept(...names) {
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.whitelistSome,
            names,
        });
        this.actions.push((key, srcRequest) => {
            const toKeep = new Set(names);
            for (let name in key.query) {
                if (!toKeep.has(name)) {
                    delete key.query[name];
                }
            }
        });
        return this;
    }
    /**
     * Adds a request header to the cache key.
     * This will have no effect on service worker cache.
     * @param name The name of the request header
     * @param createGroups A function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addHeader(name, createGroups) {
        this.actions.push((key, srcRequest) => {
            let values = srcRequest.headers[name];
            if (!Array.isArray(values)) {
                values = [values];
            }
            if (createGroups) {
                key.headers[name] = this.createGroupedValue(createGroups, values);
            }
            else {
                key.headers[name] = values;
            }
        });
        return this.addValue(`\${req:${name}}`, createGroups);
    }
    /**
     * Removes the HTTP method from the cache key.
     * @return A self-reference, suitable for chaining.
     */
    removeMethod() {
        this.actions.push((key, srcRequest) => {
            key.method = undefined;
        });
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.removeMethod,
        });
        return this;
    }
    /**
     * Removes the HTTP body from the cache key.
     * @return A self-reference, suitable for chaining.
     */
    removeBody() {
        this.actions.push((key, srcRequest) => {
            key.body = undefined;
        });
        this.config.push({
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.removeBody,
        });
        return this;
    }
    /**
     * Creates a key value for a header or cookie based on the specified group creator
     * @param createGroups the GroupCreator
     * @param srcValues The values of the header or cookie in the request
     */
    createGroupedValue(createGroups, srcValues) {
        const groups = new Groups_1.default();
        const result = [];
        createGroups(groups);
        const matchingGroup = this.findMatchingGroup(groups, srcValues);
        if (matchingGroup) {
            result.push(matchingGroup);
        }
        else {
            // if the value doesn't match any group, use the value itself
            result.push(...srcValues);
        }
        return result;
    }
    findMatchingGroup(groups, srcValues) {
        var _a;
        for (let group of groups.groups) {
            for (let value of srcValues) {
                /* istanbul ignore next */
                if ((_a = group.pattern) === null || _a === void 0 ? void 0 : _a.test(value)) {
                    return group.name;
                }
            }
        }
    }
    /**
     * Specifies that requests should be cached on a per-device basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addDevice() {
        return this.addHeader('x-0-device');
    }
    /**
     * Specifies that requests should be cached on a per-vendor basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addVendor() {
        return this.addHeader('x-0-vendor');
    }
    /**
     * Specifies that requests should be cached differently for bots.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addIsBot() {
        return this.addHeader('x-0-device-is-bot');
    }
    /**
     * Specifies that requests should be cached on a per-browser basis.
     * This will have no effect on service worker cache.
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addBrowser() {
        return this.addHeader('x-0-browser');
    }
    /**
     * Adds a cookie to the cache key.
     * This will have no effect on service worker cache.
     * @param name The name of the cookie
     * @param createGroups An function that accepts a `Groups` instance and calls `groups.group(name)` to group multiple values into a single cache key component
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addCookie(name, createGroups) {
        this.actions.push((key, srcRequest) => {
            let cookieHeader = srcRequest.headers.cookie || '';
            if (Array.isArray(cookieHeader)) {
                // Based on https://tools.ietf.org/html/rfc6265#section-5.4 we should only get a single cookie header
                // If we get more than one, we, just join them into a single parseable cookie value in case
                // the origin decides to read them all
                cookieHeader = cookieHeader.join(';');
            }
            const cookie = cookie_1.parse(cookieHeader);
            const value = cookie[name];
            if (createGroups) {
                key.cookies[name] = this.createGroupedValue(createGroups, [value]);
            }
            else {
                key.cookies[name] = value;
            }
        });
        return this.addValue(`\${req:cookie:${name}}`, createGroups);
    }
    /**
     * @private
     * @return {CustomCacheKey} A self-reference, suitable for chaining.
     */
    addValue(value, createGroups) {
        const action = {
            action: exports.CUSTOM_CACHE_KEY_ACTIONS.addValue,
            value,
        };
        if (createGroups != null) {
            const groups = new Groups_1.default();
            createGroups(groups);
            action.groups = groups.toJSON();
        }
        this.config.push(action);
        return this;
    }
    getActions() {
        return this.actions;
    }
    toJSON() {
        return this.config;
    }
}
exports.default = CustomCacheKey;
