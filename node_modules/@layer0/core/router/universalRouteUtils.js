"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
Note: this file contains functions that are needed in both the browser and the server.  These were originally
in Route.ts, but extracted in order to keep Route.ts and it's depedencies from being pulled into the browser bundle.
*/
const identity = (x) => x;
/**
 * Compares criteria object with request object and returns Boolean.
 *
 * The comparison of keys is case-sensitive by default but an optional `criteriaObjKeyNameFn`
 * parameter can be passed to force case-insensitive comparison.
 *
 * @param criteriaObj Object that contains the criteria ([key]: regex | null)
 * @param requestObj Request object that contains ([key]: string | [key]: string[] | undefined)
 * @param criteriaObjKeyNameFn Optional function to process criteria key names; by default set to `identity`
 *
 * @returns Boolean
 * true when all conditions are matching
 * false if one of the conditions failed
 */
function matchCriteriaRegexObjectWithRequestObject(criteriaObj, requestObj, criteriaObjKeyNameFn = identity) {
    let params = {};
    return (Object.entries(criteriaObj).every(([name, regex]) => {
        const value = requestObj[criteriaObjKeyNameFn(name)];
        // When regex is null we match that the value *does not* exist (the undefined case).
        // When regex is string, we convert it to regex matching the whole string.
        // When regex is a matching key (ex: ':id') and the value is a string, we extract that into
        // matcher params
        if (regex === null) {
            return value === undefined;
        }
        else if (typeof regex === 'string') {
            if (typeof value === 'string' && isParamMatcher(regex)) {
                const paramName = paramMatcherToParam(regex);
                params[paramName] = value;
                return true;
            }
            regex = new RegExp(`^${regex}$`, 'i');
        }
        return testRegExp(regex, value);
    }) && params);
}
exports.matchCriteriaRegexObjectWithRequestObject = matchCriteriaRegexObjectWithRequestObject;
/**
 * Tests to see if source object deeply matches the criteria object
 *
 * @param source Object
 * @param criteria Object
 *
 * @returns boolean
 */
function deepMatchObject(source, criteria) {
    return Object.entries(criteria).every(([key, criteriaValue]) => {
        const sourceValue = source[key];
        if (!sourceValue)
            return false;
        if (criteriaValue instanceof RegExp) {
            return testRegExp(criteriaValue, sourceValue);
        }
        else if (typeof criteriaValue === 'object' && criteriaValue !== null) {
            return deepMatchObject(sourceValue, criteriaValue);
        }
        else {
            return sourceValue == criteriaValue;
        }
    });
}
exports.deepMatchObject = deepMatchObject;
/**
 * Returns true if the value is a matcher that is used to extract
 * request params, like ':id' or ':path'
 * @param value
 */
function isParamMatcher(value) {
    return typeof value === 'string' && /^:\w+$/.test(value);
}
exports.isParamMatcher = isParamMatcher;
/**
 * Transform a route param matcher to the param name
 * ex: ':id' -> 'id'
 * @param value
 */
function paramMatcherToParam(value) {
    return value.slice(1);
}
exports.paramMatcherToParam = paramMatcherToParam;
/**
 * Ensures that the regular expression will be tested anew, without changing its internal state.
 *
 * Notes:
 * - Sometimes users use global for RegExp definitions. In those cases `.test` changes the internal
 * state and leads to different requests on subsequent calls (usually flip-flopping between
 * subsequent requests)
 *
 * @private
 * @param regexp Regular expression
 * @param value Value to test or array of values to test
 */
function testRegExp(regexp, value) {
    if (value == null) {
        return false;
    }
    if (regexp.global) {
        regexp = new RegExp(regexp);
    }
    if (Array.isArray(value)) {
        return value.some(v => regexp.test(v));
    }
    else {
        return regexp.test(value);
    }
}
exports.testRegExp = testRegExp;
