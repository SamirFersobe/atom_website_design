import { JwtAlgo } from '../types';
import Route from './Route';
import Request from './Request';
import Response from './Response';
import BackendOptions from './BackendOptions';
import { CacheOptions } from './CacheOptions';
import RequestContext from './RequestContext';
import { BaseResponseWriter, CookieOptions } from './BaseResponseWriter';
export declare const FAR_FUTURE_TTL: number;
/**
 * The API that is provided to route callbacks.
 */
export default class ResponseWriter extends BaseResponseWriter {
    private params;
    request: Request;
    response: Response;
    protected route: Route;
    private streaming;
    private context;
    private cacheKey?;
    private preCacheRequestActions;
    private postCacheRequestActions;
    private createResponseAction?;
    private preCacheResponseActions;
    private postCacheResponseActions;
    /**
     * @param req The request
     * @param res The response
     * @param route The route
     * @param defaultBackend The default backend for proxy when none is provided
     */
    constructor(req: Request, res: Response, route: Route, context: RequestContext);
    /**
     * Called at the end of the request to send the response back to the browser. Methods like proxy,
     * serveStatic, and render will replace this method with one that actually sends a response.
     * @private
     * @returns True if there send response was defined and invoked, otherwise false.
     */
    sendResponse({ beforeResponse }?: {
        beforeResponse?: Function;
    }): Promise<boolean>;
    /**
     * Logs the cache status when running locally with caching is enabled
     */
    private logCacheStatus;
    /**
     * Helper function to simplify calling interpolateParams()
     */
    private interpolateParams;
    /**
     * Copies the body, headers, and status from the cached response
     * to the outgoing response.
     * @param cachedResponse The cached response
     */
    private applyCachedResponse;
    /**
     * Rejects the request with status 412 and returns false if ?layer0_prefetch is present and
     * no cached response was found.
     */
    private validatePrefetch;
    /**
     * @param action
     */
    private setCreateResponseAction;
    /**
     * Redirects the browser to a new location.
     * Query params from the original request are added to the redirect URL
     *
     * **Examples**
     *
     * ```
     *  new Router()
     *    .get('/p/:productId', ({ redirect }) => {
     *      return redirect('/products/:productId', { statusCode: 301 })
     *    })
     *
     *  // Extract id from route and apply as query string
     *  new Router()
     *    .get('/p/:productId', ({ redirect }) => {
     *      return redirect('/product', { query: { id: ':productId' }})
     *    })
     *
     *  // Extract id from query string and apply to route
     *  new Router()
     *    .get({ path: '/p', query: { id: ':id' } }, ({ redirect }) => {
     *      return redirect('/product/:id')
     *    })
     * ```
     *
     * @param to The URL to which the browser will be redirected.
     * @param options
     * @param options.statusCode The HTTP status to return.  Defaults to 301
     * @param options.query Key-value object of query strings to be added to the redirect url
     */
    redirect: (to: string, options?: RedirectOptions) => void;
    /**
     * Relays the request to the specified backend.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path/with/:variable', ({ proxy }) => {
     *      proxy('legacy', { path: '/some/other/path/with/:variable' })
     *    })
     * ```
     *
     * In this example, we relay the request to the "legacy" backend. In this case, `layer0.config.js` must
     * contain a definition for the `legacy` backend.  For example:
     *
     * ```
     *  // layer0.config.js
     *
     *  module.exports = {
     *    backends: {
     *      legacy: {
     *        domainOrIp: 'legacy.domain.com',
     *        hostHeader: 'domain.com'
     *      }
     *    }
     *  }
     * ```
     *
     * @param backend The name of one of the backends in your `layer0.config.js` file.
     * @param options
     * @returns A promise the resolves once the response has been fetched from the upstream site.
     */
    proxy: (backend: string, options?: ProxyOptions | undefined) => Promise<void>;
    /**
     * Calls the provided callback to send a response.
     * @param cb Render callback function
     * @deprecated
     */
    render: (cb: (request: Request, proxy: (backend: string, options: ProxyOptions) => void, params: any) => void) => void;
    /**
     * Renders a result in Layer0's serverless cloud using your application. Use this method
     * to respond with an SSR or API result from your application.
     * @param options Options for transforming the request sent to your app and the response received from it.
     */
    renderWithApp: (options?: ProxyOptions | undefined) => Promise<void>;
    /**
     * Streams the result from a backend.  Can only be used in development for things
     * like hot-module reloading.
     * @param backend The name of the backend to connect to
     * @private
     */
    stream: (backend: string) => void;
    /**
     * Proxies the response from a given host
     * @private
     * @param backendConfig The backend config
     * @param options
     */
    proxyHost: (backendConfig: BackendOptions, { path, transformRequest, transformResponse, headers, removeEmptySearchParamValues, }?: ProxyOptions) => Promise<void>;
    /**
     * Rewrites the request path.
     *
     * Example:
     *
     * ```js
     *  router.get('/products/:id', ({ updatePath }) => {
     *    updatePath('/p/:id')
     *  })
     * ```
     *
     * @param destination a new route path, which can include params captured from the original path
     */
    updatePath: (destination: string) => void;
    /**
     * Updates the request's parameters based on a new path and route pattern. This is, in effect,
     * an implementation of Next.js rewrites, put here instead of NextRoutes in anticipation of other frameworks
     * implementing the same spec as many of them "follow the leader".
     *
     * **example**:
     *
     * ```js
     * res.rewrite('/category/boys/:slug*', '/category/:slug*')
     * // result: request.params will be { slug: ['category', 'boys'] }
     * ```
     * @private
     * @param destination A destination path, which may contain path variables.
     * @param pattern The path pattern for the destination route we're emulating
     */
    rewrite: (destination: string, pattern: string) => void;
    /**
     * Responds with a static asset from the specified path.
     *
     * **Example**
     *
     * ```js
     * serveStatic('path/to/asset/from/app/root')
     * ```
     *
     * You can also use variables in the asset path.  For example, to return files under the `assets` directory
     * when the url starts with `/static`:
     *
     * ```
     *  new Router()
     *    .get('/static/:path*', ({ serveStatic }) => {
     *      serveStatic('assets/:path*')
     *    })
     * ```
     *
     * Notes:
     * - if a folder contains an 'index.html', that page is also served when requesting the parent folder route.
     *   Let's take the example of /posts/1 that will render /posts/1/index.html)
     *   They are multiple components involved in this rewrite to make it work with S3 storage:
     *   1. DeploymentBuilder creates and bundles an assets-aliases.json file, that indicates that
     *     '/posts/1' should point to '/posts/1/index.html' asset file.
     *   2. layer0-subaccount-infra/components/deploy-lambda/src/deploy.js re-uploads '/posts/1/index.html'
     *     as '/posts/1' s3 key, which works because S3 is a key based storage and not a filesystem.
     *     It's a bit of a hack and takes extra space, but allows root document rendering.
     *   3. serveStatic(), both in ResponseWriter ad EdgeResponseWriter, remove any trailing slash on path
     *     so that both '/posts/1/' and '/posts/1' match the '/posts/1' S3 file
     *
     * - We did not use S3 built-in Static Website feature for multiple reasons:
     *   1. It is http only
     *   2. /build-slug/public/posts/ renders /build-slug/public/posts/index.html correctly, but /build-slug/public/posts
     *      without a trailing slash redirects to /build-slug/public/posts/.
     *      While it's easy to rewrite the path and remove trailing slashes, we actually do, it's not easy
     *      to add missing trailing slash as we don't know beforehand if the route is a directory or a file.
     *      Having a redirect on every route is not acceptable either.
     *      The Location header would also need to be rewritten to be relative to the actual website and
     *      not the bucket prefix, but that's manageable.
     *
     * - ISG/ISR:
     *   When handling a request for a static asset that is not in S3, the request follows this path:
     *
     *```
     * Browser => Edge => S3 (requested asset, which results in a 404)
     *            Edge => Buffer Proxy => S3 (options.loadingPage, if provided) => Response returned
     *                                 => Edge => Buffer Proxy => Lambda => BehindEdgeResponseWriter => options.onNotFound => SSR (then this response is cached for the next request)
     *```
     *
     *   Note that BehindEdgeResponseWriter is the key here. It overrides serveStatic and if options.onNotFound is provided, it will always be called.
     *
     * @param path The relative path to the asset from the app's root directory. You can reference path variables using `:variable`.
     * @param options The different options to serving static assets including fallback to compute
     * @returns A promise the resolves once the asset has been fetched from storage.
     */
    serveStatic: (path: string, options?: ServeStaticOptions) => Promise<void>;
    /**
     * Sets the caching behavior for both browser and edge.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     * ```
     *
     * The `cache()` method can be called in the same route where the response is sent, or any prior route.  For example,
     * with Next.js, it is common to use the next plugin to automatically inherit page routes based on Next.js conventions,
     * and use Layer0 router simply to add caching:
     *
     * ```
     *  import { Router } = from '@layer0/core/router'
     *  import { createNextPlugin } from '@layer0/next'
     *
     *  const { nextMiddleware, renderNext } = createNextPlugin()
     *
     *  new Router()
     *    .get('/p/:productId', ({ cache, proxy }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 0,
     *          serviceWorkerSeconds: 60 * 60, // 1 hour
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
     *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
     *        }
     *      })
     *      proxy('origin')
     *    })
     *    .use(nextMiddleware)
     * ```
     */
    cache: (options: CacheOptions) => void;
    /**
     * Adds or replaces a response header immediately before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setResponseHeader, proxy }) => {
     *      proxy('origin')
     *      setResponseHeader('some-header', 'some-value')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    setResponseHeader: (name: string, value: string) => void;
    private internalSetResponseHeader;
    /**
     * Alters a response header immediately before delivering the response downstream.
     * Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateResponseHeader, proxy }) => {
     *      proxy('origin')
     *      updateResponseHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateResponseHeader: (name: string, match: RegExp, replace: string) => void;
    private internalUpdateResponseHeader;
    /**
     * Removes a response header immediately before delivering the response downstream.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeResponseHeader('some-header')
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeResponseHeader: (name: string) => void;
    private internalRemoveResponseHeader;
    /**
     * Returns an array of values associated with all `set-cookie` headers.
     */
    private getSetCookieValues;
    /**
     * Returns action function for the "add response cookie" operation.
     */
    private getAddResponseCookieAction;
    /**
     * Adds a `set-cookie` header to the response before attempting to cache the response.
     * This does not replace any cookies with the same name - for that you should use `updateUpstreamResponseCookie`.
     * Furthermore, Layer0 does not cache responses with `set-cookie` so if you wish to add a cookie
     * *after* the response is cached, you should use `addResponseCookie`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      addUpstreamResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
     *    })
     * ```
     *
     * @param name Name of the cookie to add.
     * @param value Value to set
     * @param options Optional options to add to cookie
     */
    addUpstreamResponseCookie: (name: string, value: string, options?: CookieOptions | undefined) => void;
    /**
     * Adds a `set-cookie` header to the response.
     * This does not replace any cookies with the same name - for that you should use `updateResponseCookie`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ addResponseCookie, proxy }) => {
     *      proxy('origin')
     *      addResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
     *    })
     * ```
     *
     * @param name Name of the cookie to add.
     * @param value Value to set
     * @param options Optional options to add to cookie
     */
    addResponseCookie: (name: string, value: string, options?: CookieOptions | undefined) => void;
    /**
     * Returns action function for the "update response cookie" operation.
     *
     * Notes:
     * - Cookie names are case sensitive so we use case sensitive comparison.
     */
    private getUpdateResponseCookieAction;
    /**
     * Updates a `set-cookie` header in the response before attempting to cache the response.
     * If there are multiple cookies with the same name, all of them will be updated.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      updateUpstreamResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
     *    })
     * ```
     *
     * @param name Case-insensitive name of the cookie to update
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateUpstreamResponseCookie: (name: string, match: RegExp, replace: string) => void;
    /**
     * Updates a `set-cookie` header in the response. If there are multiple cookies
     * with the same name, all of them will be updated.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateResponseCookie, proxy }) => {
     *      proxy('origin')
     *      updateResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
     *    })
     * ```
     *
     * @param name Case-insensitive name of the cookie to update
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateResponseCookie: (name: string, match: RegExp, replace: string) => void;
    /**
     * Returns action function for the "remove response cookie" operation.
     *
     * Notes:
     * - Cookie names are case sensitive so we use case sensitive comparison.
     */
    private getRemoveResponseCookieAction;
    /**
     * Removes a specific `set-cookie` header from the response before attempting to cache the response.
     * If you wish to remove all such headers use `removeUpstreamHeader`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseCookie, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseCookie('my-cookie')
     *    })
     * ```
     * @param name The case-insensitive name of the cookie
     */
    removeUpstreamResponseCookie: (name: string) => void;
    /**
     * Removes a specific `set-cookie` header from the response.
     * If you wish to remove all such headers use `removeHeader`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeResponseCookie, proxy }) => {
     *      proxy('origin')
     *      removeResponseCookie('my-cookie')
     *    })
     * ```
     * @param name The case-insensitive name of the cookie
     */
    removeResponseCookie: (name: string) => void;
    /**
     * Adds or replaces an upstream response header before attempting to cache the response.
     * In local development, this is the same as calling `setResponseHeader` but on edge, it adds
     * a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      setUpstreamResponseHeader('x-0-surrogate-key', 'proxy=origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param value The value to set
     */
    setUpstreamResponseHeader: (name: string, value: string) => void;
    /**
     * Alters an upstream response header before attempting to cache the response.
     * Use this method to derive the new header value from the existing one.
     * In local development this is same as calling `updateResponseHeader` but on
     * edge it updates a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      updateUpstreamResponseHeader('cache-control', /public/gi, 'private')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the response header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateUpstreamResponseHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Removes a response header before attempting to cache the response.
     * In local development this is same as calling `updateUpstreamResponseHeader` but
     * on edge it removes a header immediately after the upstream fetch has finished.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
     *      proxy('origin')
     *      removeUpstreamResponseHeader(HTTP_HEADERS.setCookie)
     *    })
     * ```
     * @param name The case-insensitive name of the response header
     */
    removeUpstreamResponseHeader: (name: string) => void;
    /**
     * Adds or replaces a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ setRequestHeader, proxy }) => {
     *      setRequestHeader('some-header', 'some-value')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param value The value to set
     */
    setRequestHeader: (name: string, value: string) => void;
    /**
     * Returns true if the object is in the running immediately mode.
     * When object is in the running immediately mode, all otherwise
     * scheduled actions like header transform operations, are immediately
     * executed.
     * @private
     */
    private get runningImmediately();
    /**
     * Keeps count of the number of times we have started to execute any
     * workload immediately. When the counter is at zero, we are not in
     * the immediate execution mode.
     */
    private runImmediatelyDepthCounter;
    /**
     * Runs the given callback immediately, switching the response writer object
     * into immediate execution mode.
     *
     * @param callback
     */
    private runImmediately;
    /**
     * Either schedules the action for the later execution or, when running immediately,
     * executes it right away.
     *
     * @param phase Array of Functions belonging to the specific execution phase (pre-cache request, post-cache request, etc)
     * @param action Action to be executed either immediately or put into the execution array
     */
    private scheduleExecution;
    /**
     * Alters a request header. Use this method to derive the new header value from the existing one.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ updateRequestHeader, proxy }) => {
     *      updateRequestHeader('some-header', /some-.*-part/gi, 'some-replacement')
     *      proxy('origin')
     *    })
     * ```
     *
     * @param name The case-insensitive name of the request header
     * @param match Regex to find the part that should be replaced.
     * @param replace Value that will replace the matched part.
     */
    updateRequestHeader: (name: string, match: RegExp, replace: string) => void;
    /**
     * Removes a request header.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', async ({ removeRequestHeader, proxy }) => {
     *      removeRequestHeader('some-header')
     *      proxy('origin')
     *    })
     * ```
     * @param name The case-insensitive name of the request header
     */
    removeRequestHeader: (name: string) => void;
    /**
     * Returns the service worker with proper edge and browser cache headers
     * @param path The path to the service worker relative to the root directory of your app
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .get('/service-worker.js', ({ serviceWorker }) => {
     *      serviceWorker('dist/service-worker.js')
     *    })
     * ```
     */
    serviceWorker: (path: string) => void;
    /**
     * Serves an HTML app shell from a static file.
     * @param indexHtmlPath The path to the app shell html file
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .fallback(({ appShell }) => {
     *      appShell('dist/index.html')
     *    })
     * ```
     */
    appShell: (indexHtmlPath: string) => void;
    /**
     * Sends the necessary response headers to allow CORS
     * @param config
     *
     * **Example**
     *
     * ```js
     *  new Router()
     *    .match('/api/:path*', ({ allowCors }) => {
     *      allowCors({
     *        origin: '*', // this is the default
     *        methods: ['get', 'post'],
     *        headers: ['x-some-header'],
     *        maxAge: 60 * 60, // one hour
     *        credentials: true
     *      })
     *    })
     * ```
     */
    allowCors: (config?: CorsOptions) => void;
    /**
     * Sends content back to client. If content is a string, the respons will be sent
     * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path', ({ send }) => {
     *      return send('<html><body>Hello World!</body></html>', 200, 'OK')
     *    })
     * ```
     * @param content The response body as a string
     * @param statusCode The status to send
     * @param statusMessage The status message to send
     */
    send: (content: string | (() => string), statusCode?: number, statusMessage?: string | undefined) => void;
    /**
     * Execute the provided callback function in the cloud. The callback is passed the request and the response.
     *
     * Use this method when you need to compute a response in the cloud rather than at the edge or at build time. A common example
     * is when the response must be computed based on request parameters, headers, or cookies.
     *
     * A common example is to look up the destination for a redirect from an external API:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ redirect, compute }) => {
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * This method can be combined with `cache` to compute responses in the cloud and cache them at edge:
     *
     * ```js
     *  new Router()
     *    .get('/products/:id', ({ cache, redirect, compute }) => {
     *      cache({
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60,
     *        }
     *      })
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        redirect(destination)
     *      })
     *    })
     * ```
     *
     * Note: when calling `compute` in combination with `serveStatic`, the result of the `serveStatic` must be
     * awaited in order to get the result from `serveStatic`, otherwise only reslut of the `compute` method
     * will be returned.
     *
     * ```js
     * new Router()
     *   .get('/products/:id', ({ redirect, compute }) => {
     *      compute(async (request, response) => {
     *        const destination = await getDestinationFromAPI(request.params.id)
     *        await serveStatic(destination)
     *      })
     *    })
     * ```
     *
     * @param callback A function to run in the cloud to compute the response
     */
    compute: (callback: (request: Request, response: Response) => void | Promise<void>) => void;
    /**
     * Clears response action. This is required for compute and error pages. Error pages must alter the initial response and execute the error routes separately.
     *
     * @private
     * @returns
     */
    clearResponseAction(): this;
    /**
     * Send json error response to client
     * @private
     * @param err
     */
    onRouteError: (err: Error) => void;
}
/**
 * Options for the verifyJwt method. `header` and `cookie`
 * are mutually exclusive. Do not attempt to specify both, one
 * will take precedence non-deterministically. Consider the ffollowing example:
 *
 * ```typescript
 * new Router({}).match(
 *   '/protected', ({verifyJwt}) => {
 *     verifyJwt({
 *       algo: 'HS256',
 *       secret: 'supersecret',
 *       cookie: 'next-auth.session-token',
 *       redirectExpiredAbsent: '/expired',
 *       redirectInvalid: '/invalid',
 *       returnUrlParamName: 'origUrl',
 *     })
 *   }
 * )
 * ```
 *
 * On requests to `/protected` this will check for the presense of a symetrically signed (HM256,
 * shared secret) HWT in the `Cookie: next-auth.session-token=eyJh...;` part of the cookie, redirecting
 * expired to `/expired?origUrl=%2Fprotected` and invalid JWTs to `/expired?origUrl=%2Finvalid`
 * (See {@linkcode redirectExpiredAbsent} and {@linkcode redirectInvalid} for an explanation of
 * the difference).
 *
 * If neither {@linkcode redirectExpiredAbsent} nor {@linkcode redirectInvalid} are specified, then the value of {@linkcode returnUrlParamName} is ignored, and all requests are answered with an [`403 Forbidden`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403).
 */
export interface VerifyJwtOptions {
    /**
     * JWT algorithm, both symmetric and asymmetric are supported. See {@linkcode JwtAlgo}.
     *
     * **Important:** `{"algo":"none"}` is explicitly unsupported. See [here](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/) for more information.
     *
     * @type {typeof JwtAlgo::HS256}
     */
    algo: JwtAlgo;
    /** The secret, this should either be an armoued (PEM encoded including header and fooder)
     * public key for the asymmetric algorithms, or a simple secret string for the
     * symmetric algorithms. Symmetric algorithms (`HM..`) use the same secret for signing
     * and verification which is insecure if the client code (e.g a single-page-app) has the secret
     * embedded in the bundle.
     *
     * Use a symmetric algorightm (see {@linkcode JwtAlgo} for more
     * information) to use a public and private key to independently verify (public key) and
     * sign (private key) the tokens. The `ES...` family produces the smallest asymmetric
     * signatures, if overhead introduced by using JWTs is a concern.
     *
     * If using an asymmetric algorithm the value provided must be the **public** key provided in
     * [RFC7468](https://datatracker.ietf.org/doc/html/rfc7468) PEM format, such as:
     *
     * ```
     * -----BEGIN PUBLIC KEY-----
     * MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEn1LlwLN/KBYQRVH6HfIMTzfEqJOVztLe
     * kLchp2hi78cCaMY81FBlYs8J9l7krc+M4aBeCGYFjba+hiXttJWPL7ydlE+5UG4U
     * Nkn3Eos8EiZByi9DVsyfy9eejh+8AXgp
     * -----END PUBLIC KEY-----
     * ```
     */
    secret: String;
    /** The header to extract the token from. If the value of the header is prefixed with
     * `.*Bearer\ `, this will be ignored and only the following bytes decoded as a JWT.
     * e.g `Authorization: Bearer eyJh...`.
     */
    header?: String;
    /** The cookie key to extract the token from. e.g given a request header
     * `Cookie: a=eyJh...;b=session;c=etc`, setting the value `a` here will
     * extract the `a` cookie.
     */
    cookie?: String;
    /** The redirect URL to use when the JWT is expired, or absent. JWT expiry complies
     * with RFC7519 `exp` claim behaviour. JWTs rejected due to `nbf` (not before) claim
     * invalidity are also subject to this redirect, they may be understood as "expired" in
     * that they not valid yet. Invalid tokens are handled separately in {@linkcode redirectInvalid}.
     * For either case of redirect, you may specify {@linkcode returnUrlParamName} to indicate how
     * the URL redirecting the client should be forwarded; this can be used to send a client to the
     * login page and allow a seamless return.
     */
    redirectExpiredAbsent?: String;
    /** The redirect URL to use when the JWT is invalid; invalidity is defined as having a bad
     * signature, or not meeting any specific claim matching criteria which may be specified.
     * Expired/absent tokens are handled separately in {@linkcode redirectExpiredAbsent}. For
     * either case of redirect, you may specify {@linkcode returnUrlParamName} to indicate
     * how the URL redirecting the client should be forwarded; this can be used to send a client
     * to the login page and allow a seamless return.
     */
    redirectInvalid?: String;
    /** When redirecting to those URLs, then a query/search parameter will be added to the redirect
     * URL with the original URL, for example to allow the login sub system to return the user
     * to the page which triggered the redirect to login
     */
    returnUrlParamName?: String;
}
/**
 * Options for the `proxy` method
 */
export interface ProxyOptions {
    /**
     * Additional headers to send upstream
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * The path for the URL to request from the upstream site. You can reference variables
     * captured by the route pattern using `:variable`.
     *
     * **Example**
     *
     * ```
     *  new Router()
     *    .get('/some/path/with/:variable', ({ proxy }) => {
     *      proxy('legacy', { path: '/some/other/path/with/:variable' })
     *    })
     * ```
     *
     * Path can also be a function that returns a URL path string, in which case it will be computed in the cloud
     * rather than at build time.
     */
    path?: string | (() => string | undefined);
    /**
     * A function that transforms the request before it is sent to the upstream server. In general, this
     * is used to alter the request headers or body based on some conditional logic. Note that code in
     * this method will be executed at the serverless tier and not the edge.
     */
    transformRequest?: (request: Request) => void;
    /**
     * A function that transforms the response before it is returned to the browser. This function
     * typically alters `response.body` to change the content sent to the browser. It can also add, remove,
     * and alter response headers. Note that code in this method will be executed at the serverless tier
     * and not the edge.
     */
    transformResponse?: (response: Response, request: Request) => void;
    /**
     * Removes the "=" from search parameters that have no value. So for example:
     * "http://domain.com?foo=&bar=" becomes "http://domain.com?foo&bar"
     */
    removeEmptySearchParamValues?: boolean;
}
export interface CorsOptions {
    /**
     * Sets the Access-Control-Allow-Origin header.
     *
     * Access-Control-Allow-Origin specifies either a single origin, which tells browsers to allow that origin to access
     * the resource; or else — for requests without credentials — the "*" wildcard, to tell browsers to allow any
     * origin to access the resource. If omitted, "*"" will be used
     */
    origin?: string;
    /**
     * Sets the Access-Control-Allow-Methods header.
     *
     * The Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. This is used
     * in response to a preflight request. The conditions under which a request is preflighted are discussed above.
     */
    methods?: string[];
    /**
     * Sets the Access-Control-Allow-Headers header.
     *
     * The Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers
     * can be used when making the actual request.
     */
    headers?: string[];
    /**
     * Sets the Access-Control-Max-Age header.
     *
     * The Access-Control-Max-Age header indicates how long the results of a preflight request can be cached.
     * For an example of a preflight request, see the above examples.
     */
    maxAge?: number;
    /**
     * Sets the Access-Control-Allow-Credentials header.
     *
     * The Access-Control-Allow-Credentials header Indicates whether or not the response to the request can be exposed
     * when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether
     * or not the actual request can be made using credentials. Note that simple GET requests are not preflighted, and
     * so if a request is made for a resource with credentials, if this header is not returned with the resource, the
     * response is ignored by the browser and not returned to web content.
     */
    credentials?: boolean;
}
export declare type RedirectOptions = {
    /**
     * Query strings to be added to the redirect url.
     */
    query?: {
        [key: string]: string;
    };
    /**
     * HTTP Response status code for the redirect response
     * Default: 302
     */
    statusCode?: number;
} | number;
/**
 * Options for the `serveStatic` method.
 */
export interface ServeStaticOptions {
    /**
     * A function to run when no static asset exists at the specified path. Use this option to
     * perform server-side rendering for URLs that are not statically rendered at build-time.
     *
     * Example:
     *
     * ```js
     *  router.get('/products/:id', res => {
     *    res.serveStatic('dist/products/:id.html', {
     *      onNotFound: () => res.renderWithApp() // fall back to server-side rendering
     *    })
     *  })
     * ```
     *
     * Because SSR can often be slow, we recommend using this option in conjunction with
     * `loadingPage` so that users do not have to wait for SSR to finish before seeing something in their browser.
     */
    onNotFound?: (res: ResponseWriter) => Promise<void>;
    /**
     * The path to a statically rendered loading page to be served when falling back to compute. By
     * specifying both `loadingPage` and `onNotFound`, when a request cannot be fulfilled with a static asset,
     * Layer0 will instantly serve a loading page while computing a server-side rendered result for future requests.
     * This ensures that all requests will have a low time-to-first-byte (TTFB) and no user will need to
     * wait for SSR to finish before seeing something in their browser.
     *
     * Example:
     *
     * ```js
     *  router.get('/products/:id', res => {
     *    res.serveStatic('dist/products/:id.html', {
     *      onNotFound: () => res.renderWithApp(), // fall back to server-side rendering
     *      loadingPage: 'dist/products/loading.html' // show the loading page while SSR is in progress
     *    })
     *  })
     * ```
     *
     * Note that it's up to your front-end code to fetch the data to render the full page when the loading page is served.
     * Frameworks like Next.js, for example, do this automatically when you use `getStaticPaths` with `fallback: true`.
     */
    loadingPage?: string;
    /**
     * The time in seconds that the statically rendered response is considered valid.
     * Must be a positive number. If it's not specified the rendered response never expires.
     */
    expiresSeconds?: number;
    /**
     * Sets the status code for the response. If not specified, the status code will be 200.
     */
    statusCode?: number;
    /**
     * Sets the status code for the response. If not specified, the status message will be "OK".
     */
    statusMessage?: string;
    /**
     * When true, assets are served from a bucket/prefix that remains available across
     * all builds on a given environment.
     */
    permanent?: boolean;
    /**
     * List of excluded files that should not be served
     */
    exclude?: string[];
    /**
     * Set to true to prevent Layer0 from automatically publishing static files. If you enable this flag, you'll
     * need to use DeploymentBuilder.addStaticAsset(path) for each static file during the build phase.
     * @private
     */
    disableAutoPublish?: boolean;
}
