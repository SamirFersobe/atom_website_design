"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const universalRouteUtils_1 = require("./universalRouteUtils");
const cookie_1 = require("cookie");
const path_to_regexp_1 = require("path-to-regexp");
const normalizeCriteria_1 = __importDefault(require("./normalizeCriteria"));
const PathMatcher_1 = __importStar(require("./PathMatcher"));
const querystring_1 = __importDefault(require("querystring"));
const toEdgeRegex_1 = __importDefault(require("../utils/toEdgeRegex"));
const toLower_1 = __importDefault(require("../utils/toLower"));
/**
 * @private
 */
class Route {
    /**
     * Creates a new Route
     * @param criteria A string or an object with `path`, `headers`, and `method`.
     * @param handler A route handler
     * @param options A route options
     */
    constructor(criteria, handler, options) {
        this.criteria = normalizeCriteria_1.default(criteria);
        this.handler = handler;
        this.options = options;
        if (this.criteria.path) {
            this.matcher = new PathMatcher_1.default(this.criteria.path);
        }
    }
    /**
     * Returns params if route matches the request's method, headers, cookies and path.
     * @param req
     * @return The path params if the route matches the current request, otherwise false
     */
    match(req) {
        // Params are mostly extracted from path, but in they can also be extracted from query string, header, cookie, etc.
        // although that would need to be implemented at EDGE too, which in general is not trivial.
        // As of now, on EDGE, this is only implemented for query string params to inject in redirect()
        const matchParamsFns = [
            this.matchPath,
            this.matchProtocol,
            this.matchMethod,
            this.matchHeaders,
            this.matchQueryParams,
            this.matchCookies,
            this.matchBody,
        ];
        const mergedParams = {};
        for (const matchParamsFn of matchParamsFns) {
            const paramsOrBoolean = matchParamsFn.bind(this)(req);
            if (!paramsOrBoolean) {
                // One matcher failed, no need to go further
                return false;
            }
            Object.assign(mergedParams, paramsOrBoolean);
        }
        // We wait until now before assigning params to the request so we are sure the route actually matched the request.
        req.params = mergedParams;
        return mergedParams;
    }
    /**
     * Matches response. This is used for error routes and each route that contains response matcher is considered as
     * a route for handling the error pages. Each error route must send a response.
     * @param res Response
     * @returns
     */
    matchResponse(res) {
        return this.matchResponseStatus(res);
    }
    matchResponseStatus(res) {
        var _a, _b, _c;
        if ((_b = (_a = this.criteria) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.statusCode) {
            return !!((_c = res.statusCode) === null || _c === void 0 ? void 0 : _c.toString().match(this.criteria.response.statusCode));
        }
        return false;
    }
    // Match criteria path to request url
    matchPath(req) {
        if (this.matcher) {
            return this.matcher.match(req.path);
        }
        else {
            return {}; // return a match with no params
        }
    }
    // Match criteria method to request method
    matchMethod(req) {
        if (!this.criteria.method || !req.method) {
            return true;
        }
        return new RegExp(this.criteria.method, 'i').test(req.method);
    }
    /**
     * Run thru criteria headers and match with request headers.
     *
     * Header names are *not* case-sensitive and they are all lower-cased per Node behavior we pass `toLower` to matcher function.
     *
     * @param req Request object
     */
    matchHeaders(req) {
        if (this.criteria.headers) {
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.headers, req.headers, toLower_1.default);
        }
        return true;
    }
    /**
     * Matches JSON body based on given criteria
     *
     * @param req Request object
     *
     * @returns Boolean
     */
    matchBody(req) {
        if (this.criteria.body && this.criteria.body.parse == 'json' && req.body) {
            let bodyObject;
            try {
                bodyObject = JSON.parse(req.body);
            }
            catch {
                return false;
            }
            return universalRouteUtils_1.deepMatchObject(bodyObject, this.criteria.body.criteria);
        }
        return true;
    }
    /**
     * Run thru criteria query and match with request query parameters.
     *
     * Query string names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    matchQueryParams(req) {
        if (this.criteria.query) {
            // When there's no query params it means there's no way it's a match when criteria is set
            if (!req.query) {
                return false;
            }
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.query, req.query);
        }
        return true;
    }
    /**
     * Run thru criteria cookies and match with request cookies.
     *
     * Cookie names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    matchCookies(req) {
        if (this.criteria.cookies) {
            const cookieHeader = req.headers['cookie'];
            if (cookieHeader == null) {
                // When there is no cookie header, we return true only if all matchers
                // on cookies are null meaning "cookie not present".
                return Object.values(this.criteria.cookies).every(regex => regex === null);
            }
            const cookieValue = Array.isArray(cookieHeader) ? cookieHeader.join('; ') : cookieHeader;
            const reqCookies = cookie_1.parse(cookieValue);
            return universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(this.criteria.cookies, reqCookies);
        }
        return true;
    }
    /**
     * Match the protocol for the request. All routes have the implicit `https` protocol
     * unless explicitly specified as something else.
     *
     * Because HTTP is a subset of HTTPS we make sure that when strings are used we match
     * the whole value rather than just a part of it.
     *
     * @param req Request object
     */
    matchProtocol(req) {
        const protocol = (req.headers && req.headers[constants_1.HTTP_HEADERS.x0Protocol]) || 'https';
        let criteriaProtocolRegex;
        if (typeof this.criteria.protocol === 'string') {
            criteriaProtocolRegex = new RegExp(`^${this.criteria.protocol}$`, 'i');
        }
        else {
            criteriaProtocolRegex = new RegExp(this.criteria.protocol || '^https$', 'i');
        }
        return universalRouteUtils_1.testRegExp(criteriaProtocolRegex, protocol);
    }
    toString() {
        const { path, ...criteria } = this.criteria;
        if (Object.keys(criteria).length) {
            return JSON.stringify(this.criteria);
        }
        else if (path) {
            return path;
        }
        else {
            return 'fallback';
        }
    }
    toRegex() {
        return Route.toRegexp(this.criteria.path);
    }
    /**
     * Returns criteria json
     * This is consumed by cache metrics that will transform the route to be as similar as in routes file
     */
    toJson() {
        var _a;
        return JSON.stringify({ ...this.criteria, label: (_a = this.options) === null || _a === void 0 ? void 0 : _a.label }, (_, value) => {
            // We have to convert regular expressions to string otherwise it will not be logged
            if (value instanceof RegExp) {
                return value.toString();
            }
            return value;
        });
    }
    /**
     * Returns a string with the regex representation of the route.
     * @returns Regexp string representation of the route
     */
    toRegexString() {
        return this.toRegex().source;
    }
    /**
     * Returns a regex string compatible with the edge regular express parser
     */
    toEdgeRegexString() {
        return Route.toEdgeRegexString(this.criteria.path);
    }
    /**
     * Returns if the route should match response criteria.
     *
     * @returns
     */
    isRespRoute() {
        return !!this.criteria.response;
    }
    static toRegexp(path) {
        if (path) {
            try {
                return path_to_regexp_1.pathToRegexp(path);
            }
            catch (e) {
                throw new PathMatcher_1.PathMatcherError(path);
            }
        }
        else {
            // For fallbacks we want everything matched so that we can replace everything if needed.
            // We insist on total matching with `^` and `$` because some regex replacement algorithms
            // have issues with correctly applying `.*` in completely greedy manner (e.g. Fastly's `regsuball`)
            return /^.*$/;
        }
    }
    static toEdgeRegexString(path) {
        return toEdgeRegex_1.default(Route.toRegexp(path));
    }
    /**
     * Generate a path-to-regexp comptible path that includes query strings
     * In path-to-regexp, '?' is a special character so it needs to be escaped
     *
     * Note that we prevent querystring from escaping ':', which is used to inject
     * matched params from the path
     *
     * @param path
     * @param query
     */
    static pathWithQueryString(path, query) {
        const queryString = querystring_1.default.stringify(query).replace(/%3A/g, ':');
        return path + (queryString && `\\?${queryString}`);
    }
}
exports.default = Route;
