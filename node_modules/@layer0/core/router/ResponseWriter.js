"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
const bindParamsToPath_1 = __importDefault(require("../utils/bindParamsToPath"));
const config_1 = __importDefault(require("../config"));
const Backend_1 = __importDefault(require("./Backend"));
const interpolateParams_1 = __importDefault(require("./interpolateParams"));
const stream_1 = __importDefault(require("./stream"));
const constants_1 = require("../constants");
const environment_1 = require("../environment");
const validateWriter_1 = require("./validateWriter");
const Route_1 = __importDefault(require("./Route"));
const decode_1 = __importDefault(require("../utils/decode"));
const Cache_1 = require("../cache/Cache");
const CacheKey_1 = __importDefault(require("../cache/CacheKey"));
const timing_1 = require("../timing");
const PathMatcher_1 = __importDefault(require("./PathMatcher"));
const nonWebpackRequire_1 = __importDefault(require("../utils/nonWebpackRequire"));
const logo_1 = require("../utils/logo");
const BaseResponseWriter_1 = require("./BaseResponseWriter");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const mergeQueryString_1 = __importDefault(require("./mergeQueryString"));
const slash_1 = __importDefault(require("slash"));
exports.FAR_FUTURE_TTL = 60 * 60 * 24 * 365 * 10;
/**
 * The API that is provided to route callbacks.
 */
class ResponseWriter extends BaseResponseWriter_1.BaseResponseWriter {
    /**
     * @param req The request
     * @param res The response
     * @param route The route
     * @param defaultBackend The default backend for proxy when none is provided
     */
    constructor(req, res, route, context) {
        super(req, res, route);
        this.params = {}; // Merged/All params
        this.streaming = false;
        // request/response phases
        this.preCacheRequestActions = [];
        this.postCacheRequestActions = [];
        this.preCacheResponseActions = [];
        this.postCacheResponseActions = [];
        /**
         * Helper function to simplify calling interpolateParams()
         */
        this.interpolateParams = (value) => {
            return interpolateParams_1.default(this.request, this.response, value);
        };
        /**
         * Redirects the browser to a new location.
         * Query params from the original request are added to the redirect URL
         *
         * **Examples**
         *
         * ```
         *  new Router()
         *    .get('/p/:productId', ({ redirect }) => {
         *      return redirect('/products/:productId', { statusCode: 301 })
         *    })
         *
         *  // Extract id from route and apply as query string
         *  new Router()
         *    .get('/p/:productId', ({ redirect }) => {
         *      return redirect('/product', { query: { id: ':productId' }})
         *    })
         *
         *  // Extract id from query string and apply to route
         *  new Router()
         *    .get({ path: '/p', query: { id: ':id' } }, ({ redirect }) => {
         *      return redirect('/product/:id')
         *    })
         * ```
         *
         * @param to The URL to which the browser will be redirected.
         * @param options
         * @param options.statusCode The HTTP status to return.  Defaults to 301
         * @param options.query Key-value object of query strings to be added to the redirect url
         */
        this.redirect = (to, options = {}) => {
            const { to: toPath, statusCode, query } = this._readRedirectParams(to, options);
            const redirectLocation = mergeQueryString_1.default(this.request.url, bindParamsToPath_1.default(
            // We do interpolation here while running in browser since URL works differently in browser and server.
            // This works without interpolating here and doing it later in patchResWriteHead when running on server but
            // not in browser (e.g in fiddle). This is because browser is encoding the URL in some cases where server doesn't.
            //
            // Example:
            // Server: new URL('https://www.example.com${url}', 'http://foo.com').toString() == 'https://www.example.com${url}/'
            // Browser: new URL('https://www.example.com${url}', 'http://foo.com').toString() == 'https://www.example.com%24%7Burl%7D/'
            environment_1.isBrowser()
                ? this.interpolateParams(Route_1.default.pathWithQueryString(toPath, query))
                : Route_1.default.pathWithQueryString(toPath, query), this.request.params));
            this.setResponseHeader(constants_1.HTTP_HEADERS.location, redirectLocation);
            this.send('', statusCode);
        };
        /**
         * Relays the request to the specified backend.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path/with/:variable', ({ proxy }) => {
         *      proxy('legacy', { path: '/some/other/path/with/:variable' })
         *    })
         * ```
         *
         * In this example, we relay the request to the "legacy" backend. In this case, `layer0.config.js` must
         * contain a definition for the `legacy` backend.  For example:
         *
         * ```
         *  // layer0.config.js
         *
         *  module.exports = {
         *    backends: {
         *      legacy: {
         *        domainOrIp: 'legacy.domain.com',
         *        hostHeader: 'domain.com'
         *      }
         *    }
         *  }
         * ```
         *
         * @param backend The name of one of the backends in your `layer0.config.js` file.
         * @param options
         * @returns A promise the resolves once the response has been fetched from the upstream site.
         */
        this.proxy = async (backend, options) => {
            const backendConfig = config_1.default.get(`backends.${backend}`);
            await this.proxyHost(backendConfig, options);
        };
        /**
         * Calls the provided callback to send a response.
         * @param cb Render callback function
         * @deprecated
         */
        this.render = (cb) => {
            console.warn(`${logo_1.warnLogLabel} Warning ResponseWriter#render is deprecated.`);
            cb(this.request, this.proxy, this.request.params);
        };
        /**
         * Renders a result in Layer0's serverless cloud using your application. Use this method
         * to respond with an SSR or API result from your application.
         * @param options Options for transforming the request sent to your app and the response received from it.
         */
        this.renderWithApp = (options) => this.proxy(constants_1.BACKENDS.js, options);
        /**
         * Streams the result from a backend.  Can only be used in development for things
         * like hot-module reloading.
         * @param backend The name of the backend to connect to
         * @private
         */
        this.stream = (backend) => {
            if (process.env.NODE_ENV === 'production') {
                throw new Error('stream can only be used in development');
            }
            let backendConfig = normalizeBackendConfig(config_1.default.get(`backends.${backend}`));
            this.response.setHeader(constants_1.HTTP_HEADERS.contentType, 'text/event-stream');
            this.streaming = true;
            stream_1.default(this.request, this.response, backendConfig, Function.prototype);
            this.setCreateResponseAction(() => Promise.resolve()); // to prevent the router from continuing on to the next route
        };
        /**
         * Proxies the response from a given host
         * @private
         * @param backendConfig The backend config
         * @param options
         */
        this.proxyHost = async (backendConfig, { path, transformRequest, transformResponse, headers, removeEmptySearchParamValues, } = {}) => {
            backendConfig = normalizeBackendConfig(backendConfig);
            const backend = Backend_1.default.create(backendConfig);
            let pathString;
            if (typeof path === 'function') {
                pathString = path();
            }
            else {
                pathString = path;
            }
            pathString = pathString ? bindParamsToPath_1.default(pathString, this.request.params) : pathString;
            await this.setCreateResponseAction(async () => {
                try {
                    if (transformRequest) {
                        const transformRequestTime = new timing_1.InternalTiming(timing_1.InternalNames.transformRequest).start();
                        try {
                            await this.runImmediately(() => transformRequest(this.request));
                        }
                        finally {
                            transformRequestTime.end();
                        }
                    }
                    const fetchTime = new timing_1.InternalTiming(timing_1.InternalNames.proxying).start();
                    try {
                        await backend.fetch(this.request, this.response, {
                            path: pathString || this.request.url,
                            disableCheckCert: backendConfig.disableCheckCert,
                            headers,
                            removeEmptySearchParamValues,
                        });
                    }
                    finally {
                        fetchTime.end();
                    }
                    if (transformResponse) {
                        const transformResponseTime = new timing_1.InternalTiming(timing_1.InternalNames.transformResponse).start();
                        try {
                            decode_1.default(this.response);
                            await this.runImmediately(() => transformResponse(this.response, this.request));
                        }
                        finally {
                            transformResponseTime.end();
                        }
                    }
                }
                catch (e) {
                    if (e.type === 'BackendFetchError') {
                        // will get here when there is a connection error with the backend
                        console.error(`${logo_1.errorLogLabel} Could not connect to backend ${backendConfig.domainOrIp}:`, e.message);
                        this.response.statusCode = 503;
                    }
                    else {
                        console.error(`${logo_1.errorLogLabel} Error in ResponseWriter:`, e.message, e.stack);
                        this.response.statusCode = 500;
                    }
                }
            });
        };
        /**
         * Rewrites the request path.
         *
         * Example:
         *
         * ```js
         *  router.get('/products/:id', ({ updatePath }) => {
         *    updatePath('/p/:id')
         *  })
         * ```
         *
         * @param destination a new route path, which can include params captured from the original path
         */
        this.updatePath = (destination) => {
            const path = bindParamsToPath_1.default(destination, this.request.params);
            // IncomingMessage defines path as only having a getter, so we need to redefine it, we can't just set path = destination, which would result in an error in development.
            Object.defineProperty(this.request, 'path', {
                get: () => path,
            });
        };
        /**
         * Updates the request's parameters based on a new path and route pattern. This is, in effect,
         * an implementation of Next.js rewrites, put here instead of NextRoutes in anticipation of other frameworks
         * implementing the same spec as many of them "follow the leader".
         *
         * **example**:
         *
         * ```js
         * res.rewrite('/category/boys/:slug*', '/category/:slug*')
         * // result: request.params will be { slug: ['category', 'boys'] }
         * ```
         * @private
         * @param destination A destination path, which may contain path variables.
         * @param pattern The path pattern for the destination route we're emulating
         */
        this.rewrite = (destination, pattern) => {
            const path = bindParamsToPath_1.default(destination, this.request.params);
            const newUrl = new URL(this.request.url, 'http://host');
            newUrl.pathname = path;
            this.request.url = newUrl.pathname + newUrl.search;
            this.request.path = path;
            this.request.params = new PathMatcher_1.default(pattern).match(path);
        };
        /**
         * Responds with a static asset from the specified path.
         *
         * **Example**
         *
         * ```js
         * serveStatic('path/to/asset/from/app/root')
         * ```
         *
         * You can also use variables in the asset path.  For example, to return files under the `assets` directory
         * when the url starts with `/static`:
         *
         * ```
         *  new Router()
         *    .get('/static/:path*', ({ serveStatic }) => {
         *      serveStatic('assets/:path*')
         *    })
         * ```
         *
         * Notes:
         * - if a folder contains an 'index.html', that page is also served when requesting the parent folder route.
         *   Let's take the example of /posts/1 that will render /posts/1/index.html)
         *   They are multiple components involved in this rewrite to make it work with S3 storage:
         *   1. DeploymentBuilder creates and bundles an assets-aliases.json file, that indicates that
         *     '/posts/1' should point to '/posts/1/index.html' asset file.
         *   2. layer0-subaccount-infra/components/deploy-lambda/src/deploy.js re-uploads '/posts/1/index.html'
         *     as '/posts/1' s3 key, which works because S3 is a key based storage and not a filesystem.
         *     It's a bit of a hack and takes extra space, but allows root document rendering.
         *   3. serveStatic(), both in ResponseWriter ad EdgeResponseWriter, remove any trailing slash on path
         *     so that both '/posts/1/' and '/posts/1' match the '/posts/1' S3 file
         *
         * - We did not use S3 built-in Static Website feature for multiple reasons:
         *   1. It is http only
         *   2. /build-slug/public/posts/ renders /build-slug/public/posts/index.html correctly, but /build-slug/public/posts
         *      without a trailing slash redirects to /build-slug/public/posts/.
         *      While it's easy to rewrite the path and remove trailing slashes, we actually do, it's not easy
         *      to add missing trailing slash as we don't know beforehand if the route is a directory or a file.
         *      Having a redirect on every route is not acceptable either.
         *      The Location header would also need to be rewritten to be relative to the actual website and
         *      not the bucket prefix, but that's manageable.
         *
         * - ISG/ISR:
         *   When handling a request for a static asset that is not in S3, the request follows this path:
         *
         *```
         * Browser => Edge => S3 (requested asset, which results in a 404)
         *            Edge => Buffer Proxy => S3 (options.loadingPage, if provided) => Response returned
         *                                 => Edge => Buffer Proxy => Lambda => BehindEdgeResponseWriter => options.onNotFound => SSR (then this response is cached for the next request)
         *```
         *
         *   Note that BehindEdgeResponseWriter is the key here. It overrides serveStatic and if options.onNotFound is provided, it will always be called.
         *
         * @param path The relative path to the asset from the app's root directory. You can reference path variables using `:variable`.
         * @param options The different options to serving static assets including fallback to compute
         * @returns A promise the resolves once the asset has been fetched from storage.
         */
        this.serveStatic = async (path, options = {}) => {
            let filePath = path && bindParamsToPath_1.default(path, this.request.params);
            const { permanent, exclude } = options;
            // Remove trailing '/' so that both /path/ and /path are
            // served by /path file.
            filePath = filePath.replace(/\/$/, '');
            if (exclude === null || exclude === void 0 ? void 0 : exclude.some(excludedFile => filePath.indexOf(excludedFile) >= 0)) {
                return this.send('404 - Not found', 404);
            }
            if (environment_1.isCloud()) {
                const staticBackend = config_1.default.get(`backends.${permanent ? constants_1.BACKENDS.permanentStatic : constants_1.BACKENDS.static}`);
                // AWS
                // Static assets are stored in s3 in production, so we just need to proxy
                // s3 for all of the correct headers to be sent and the correct file to be served.
                await this.proxyHost(staticBackend, {
                    path: slash_1.default(filePath),
                    transformResponse: async (res) => {
                        // In production on the edge files served from AmazonS3 without any defined cache have default cache-control header.
                        // We want to simulate this header on local too.
                        res.setHeader(constants_1.HTTP_HEADERS.cacheControl, `s-maxage=${exports.FAR_FUTURE_TTL}`);
                        // S3 returns 403 on actual 404. We do the same thing in our local static file server.
                        if (res.statusCode === 403) {
                            if (options.loadingPage) {
                                await this.proxyHost(config_1.default.get(`backends.${constants_1.BACKENDS.static}`), {
                                    path: bindParamsToPath_1.default(options.loadingPage, this.request.params),
                                });
                            }
                            else if (options.onNotFound) {
                                await options.onNotFound(this);
                            }
                            else {
                                // We translate the S3 403 into a 404. The edge does the same thing.
                                res.statusCode = 404;
                                res.statusMessage = 'Not Found';
                            }
                        }
                        // Set the optional status code and message to the static response.
                        if (options.statusCode) {
                            res.statusCode = options.statusCode;
                        }
                        if (options.statusMessage) {
                            res.statusMessage = options.statusMessage;
                        }
                    },
                });
            }
            else {
                // local development
                if (!fs_1.default.existsSync(filePath)) {
                    return this.send('404 - Not found', 404);
                }
                // Try serving root document "($path)/index.html" for paths matching
                // a directory.
                // We achieve the same result on S3 via assets-aliases.json.
                if (fs_1.default.lstatSync(filePath).isDirectory()) {
                    filePath = path_1.join(filePath, './index.html');
                }
                const stat = fs_1.default.statSync(filePath);
                // not needed in production, so we leave it out to keep the bundle small
                const mime = nonWebpackRequire_1.default('mime-types');
                const chardet = nonWebpackRequire_1.default('chardet');
                let contentType = mime.lookup(filePath);
                // connascence with xdn-subaccount-infra - s3Bucket.js
                if (contentType) {
                    try {
                        const encodingAnalysisResult = chardet.analyse(fs_1.default.readFileSync(filePath));
                        if (encodingAnalysisResult.length > 0) {
                            // chardet analyse returns array of possible encodings starting with most confident result
                            const { name: encoding, confidence } = encodingAnalysisResult[0];
                            if (encoding && confidence > 90) {
                                contentType += `; charset=${encoding}`;
                            }
                        }
                    }
                    catch (e) {
                        // will get here if a charset fails to be detected
                    }
                }
                else {
                    contentType = 'application/octet-stream';
                }
                // Using setUpstreamResponseHeader gives developers the opportunity to override this,
                // just like they would in production, where the content-type header comes from S3 based
                // on the metadata that is associated with the file at the time of upload.
                this.setUpstreamResponseHeader(constants_1.HTTP_HEADERS.contentType, contentType);
                // We don't allow developers to manipulate content-length header through the router
                // (it's prohibited on the edge as it could lead to broken responses)
                // In this case we know we are not running in the cloud so our code is free to do so.
                this.internalSetResponseHeader(constants_1.HTTP_HEADERS.contentLength, stat.size.toString(), false, this.postCacheResponseActions);
                if (options.statusCode) {
                    this.response.statusCode = options.statusCode;
                    this.response.statusMessage = options.statusMessage;
                }
                await this.setCreateResponseAction(() => {
                    return new Promise((resolve, reject) => {
                        fs_1.default.readFile(filePath, (err, data) => {
                            /* istanbul ignore if */
                            if (err) {
                                reject(err);
                            }
                            else {
                                this.response.body = data;
                                resolve();
                            }
                        });
                    });
                });
            }
        };
        /**
         * Sets the caching behavior for both browser and edge.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/p/:productId', ({ cache, proxy }) => {
         *      cache({
         *        browser: {
         *          maxAgeSeconds: 0,
         *          serviceWorkerSeconds: 60 * 60, // 1 hour
         *        },
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
         *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
         *        }
         *      })
         *      proxy('origin')
         *    })
         * ```
         *
         * The `cache()` method can be called in the same route where the response is sent, or any prior route.  For example,
         * with Next.js, it is common to use the next plugin to automatically inherit page routes based on Next.js conventions,
         * and use Layer0 router simply to add caching:
         *
         * ```
         *  import { Router } = from '@layer0/core/router'
         *  import { createNextPlugin } from '@layer0/next'
         *
         *  const { nextMiddleware, renderNext } = createNextPlugin()
         *
         *  new Router()
         *    .get('/p/:productId', ({ cache, proxy }) => {
         *      cache({
         *        browser: {
         *          maxAgeSeconds: 0,
         *          serviceWorkerSeconds: 60 * 60, // 1 hour
         *        },
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24, // 24 hours
         *          staleWhileRevalidateSeconds: 60 * 60 // 1 hour
         *        }
         *      })
         *      proxy('origin')
         *    })
         *    .use(nextMiddleware)
         * ```
         */
        this.cache = (options) => {
            const { browser, edge, key } = options;
            if (edge) {
                const { maxAgeSeconds, staleWhileRevalidateSeconds, forcePrivateCaching } = edge;
                const value = [];
                // Flip force-private-caching only if it is explicitly set.
                if (typeof forcePrivateCaching !== 'undefined') {
                    this.context.forcePrivateCaching = forcePrivateCaching === true;
                }
                this.cacheKey = key;
                if (typeof this.route.criteria.method === 'string') {
                    this.context.cacheRouteMethod = this.route.criteria.method;
                }
                if (maxAgeSeconds) {
                    value.push('max-age=' + maxAgeSeconds);
                    if (staleWhileRevalidateSeconds) {
                        value.push('stale-while-revalidate=' + staleWhileRevalidateSeconds);
                    }
                }
                if (value.length) {
                    this.internalSetResponseHeader(constants_1.HTTP_HEADERS.x0CacheControl, value.join(', '), false, this.preCacheResponseActions);
                }
            }
            if (browser || browser === false) {
                const { maxAgeSeconds, serviceWorkerSeconds } = browser || { maxAgeSeconds: 0 };
                if (serviceWorkerSeconds && maxAgeSeconds && maxAgeSeconds > 0) {
                    console.error(`${logo_1.errorLogLabel} Within the caching configuration of your "${this.route.criteria.path}" route, when service worker caching is set, the browser max age must be set to zero. Refer to https://docs.layer0.co/guides/caching#section_caching_a_response`);
                    throw new Error('When service worker caching is set, the browser max age must be set to zero. Refer to https://docs.layer0.co/guides/caching#section_caching_a_response');
                }
                if (maxAgeSeconds === 0) {
                    this.setResponseHeader(constants_1.HTTP_HEADERS.cacheControl, 'private, no-store, no-cache');
                }
                else if (maxAgeSeconds) {
                    // Here we use "private" instead of "public" to prevent downstream CDNs from caching the asset
                    // Since we already have an explicit way to cache at edge, we choose to keep browser and edge
                    // caching totally separate.
                    this.setResponseHeader(constants_1.HTTP_HEADERS.cacheControl, `private, max-age=${maxAgeSeconds}`);
                }
                if (serviceWorkerSeconds) {
                    this.setResponseHeader(constants_1.HTTP_HEADERS.xSwCacheControl, `max-age=${serviceWorkerSeconds}`);
                }
            }
        };
        /**
         * Adds or replaces a response header immediately before delivering the response downstream.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setResponseHeader, proxy }) => {
         *      proxy('origin')
         *      setResponseHeader('some-header', 'some-value')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param value The value to set
         */
        this.setResponseHeader = (name, value) => {
            this.internalSetResponseHeader(name, value, true, this.postCacheResponseActions);
        };
        this.internalSetResponseHeader = (name, value, validate, phase) => {
            if (validate) {
                validateWriter_1.validateSetResponseHeader(name);
            }
            this.scheduleExecution(phase, () => {
                const interpolatedValue = this.interpolateParams(value);
                this.response.setHeader(name, interpolatedValue);
            });
        };
        /**
         * Alters a response header immediately before delivering the response downstream.
         * Use this method to derive the new header value from the existing one.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateResponseHeader, proxy }) => {
         *      proxy('origin')
         *      updateResponseHeader('some-header', /some-.*-part/gi, 'some-replacement')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateResponseHeader = (name, match, replace) => {
            this.internalUpdateResponseHeader(name, match, replace, this.preCacheResponseActions);
        };
        this.internalUpdateResponseHeader = (name, match, replace, phase) => {
            validateWriter_1.validateUpdateResponseHeader(name);
            this.scheduleExecution(phase, () => {
                const currentValue = this.response.getHeader(name);
                const interpolatedReplace = this.interpolateParams(replace);
                if (currentValue) {
                    this.response.setHeader(name, currentValue.replace(match, interpolatedReplace));
                }
            });
        };
        /**
         * Removes a response header immediately before delivering the response downstream.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeResponseHeader, proxy }) => {
         *      proxy('origin')
         *      removeResponseHeader('some-header')
         *    })
         * ```
         * @param name The case-insensitive name of the response header
         */
        this.removeResponseHeader = (name) => {
            this.internalRemoveResponseHeader(name, this.postCacheResponseActions);
        };
        this.internalRemoveResponseHeader = (name, phase) => {
            validateWriter_1.validateRemoveResponseHeader(name);
            this.scheduleExecution(phase, () => {
                this.response.removeHeader(name);
            });
        };
        /**
         * Returns an array of values associated with all `set-cookie` headers.
         */
        this.getSetCookieValues = () => {
            const headers = this.response.getHeader(constants_1.HTTP_HEADERS.setCookie);
            if (typeof headers === 'string') {
                return [headers];
            }
            return headers || [];
        };
        /**
         * Returns action function for the "add response cookie" operation.
         */
        this.getAddResponseCookieAction = (name, value, options = {}) => {
            return () => {
                const setCookies = this.getSetCookieValues();
                const interpolatedValue = this.interpolateParams(value);
                let cookie = `${name}=${interpolatedValue}`;
                let key;
                for (key in options) {
                    const opt = options[key];
                    if (typeof opt === 'boolean' && opt) {
                        cookie += `; ${key}`;
                    }
                    else {
                        cookie += `; ${key}=${opt}`;
                    }
                }
                this.response.setHeader(constants_1.HTTP_HEADERS.setCookie, [...setCookies, cookie]);
            };
        };
        /**
         * Adds a `set-cookie` header to the response before attempting to cache the response.
         * This does not replace any cookies with the same name - for that you should use `updateUpstreamResponseCookie`.
         * Furthermore, Layer0 does not cache responses with `set-cookie` so if you wish to add a cookie
         * *after* the response is cached, you should use `addResponseCookie`.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ addUpstreamResponseCookie, proxy }) => {
         *      proxy('origin')
         *      addUpstreamResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
         *    })
         * ```
         *
         * @param name Name of the cookie to add.
         * @param value Value to set
         * @param options Optional options to add to cookie
         */
        this.addUpstreamResponseCookie = (name, value, options) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.preCacheResponseActions, this.getAddResponseCookieAction(name, value, options));
        };
        /**
         * Adds a `set-cookie` header to the response.
         * This does not replace any cookies with the same name - for that you should use `updateResponseCookie`.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ addResponseCookie, proxy }) => {
         *      proxy('origin')
         *      addResponseCookie('my-cookie', 'my-cookie-value', { domain: 'test.com' })
         *    })
         * ```
         *
         * @param name Name of the cookie to add.
         * @param value Value to set
         * @param options Optional options to add to cookie
         */
        this.addResponseCookie = (name, value, options) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.postCacheResponseActions, this.getAddResponseCookieAction(name, value, options));
        };
        /**
         * Returns action function for the "update response cookie" operation.
         *
         * Notes:
         * - Cookie names are case sensitive so we use case sensitive comparison.
         */
        this.getUpdateResponseCookieAction = (name, match, replace) => {
            return () => {
                const setCookies = this.getSetCookieValues().map((cookie) => {
                    let [cookieName, ...cookieValues] = cookie.split('=');
                    if (cookieName !== name) {
                        return cookie;
                    }
                    const cookieValue = cookieValues.join('=').replace(match, replace);
                    return [cookieName, cookieValue].join('=');
                });
                this.response.setHeader(constants_1.HTTP_HEADERS.setCookie, setCookies);
            };
        };
        /**
         * Updates a `set-cookie` header in the response before attempting to cache the response.
         * If there are multiple cookies with the same name, all of them will be updated.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateUpstreamResponseCookie, proxy }) => {
         *      proxy('origin')
         *      updateUpstreamResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
         *    })
         * ```
         *
         * @param name Case-insensitive name of the cookie to update
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateUpstreamResponseCookie = (name, match, replace) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.preCacheResponseActions, this.getUpdateResponseCookieAction(name, match, replace));
        };
        /**
         * Updates a `set-cookie` header in the response. If there are multiple cookies
         * with the same name, all of them will be updated.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateResponseCookie, proxy }) => {
         *      proxy('origin')
         *      updateResponseCookie('my-cookie', /Domain=.+;/, 'Domain=mydomain.com;')
         *    })
         * ```
         *
         * @param name Case-insensitive name of the cookie to update
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateResponseCookie = (name, match, replace) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.postCacheResponseActions, this.getUpdateResponseCookieAction(name, match, replace));
        };
        /**
         * Returns action function for the "remove response cookie" operation.
         *
         * Notes:
         * - Cookie names are case sensitive so we use case sensitive comparison.
         */
        this.getRemoveResponseCookieAction = (name) => {
            return () => {
                const setCookies = this.getSetCookieValues().filter((cookie) => cookie.split('=')[0] !== name);
                this.response.setHeader(constants_1.HTTP_HEADERS.setCookie, setCookies);
            };
        };
        /**
         * Removes a specific `set-cookie` header from the response before attempting to cache the response.
         * If you wish to remove all such headers use `removeUpstreamHeader`.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeUpstreamResponseCookie, proxy }) => {
         *      proxy('origin')
         *      removeUpstreamResponseCookie('my-cookie')
         *    })
         * ```
         * @param name The case-insensitive name of the cookie
         */
        this.removeUpstreamResponseCookie = (name) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.preCacheResponseActions, this.getRemoveResponseCookieAction(name));
        };
        /**
         * Removes a specific `set-cookie` header from the response.
         * If you wish to remove all such headers use `removeHeader`.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeResponseCookie, proxy }) => {
         *      proxy('origin')
         *      removeResponseCookie('my-cookie')
         *    })
         * ```
         * @param name The case-insensitive name of the cookie
         */
        this.removeResponseCookie = (name) => {
            validateWriter_1.validateCookieName(name);
            this.scheduleExecution(this.postCacheResponseActions, this.getRemoveResponseCookieAction(name));
        };
        /**
         * Adds or replaces an upstream response header before attempting to cache the response.
         * In local development, this is the same as calling `setResponseHeader` but on edge, it adds
         * a header immediately after the upstream fetch has finished.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setUpstreamResponseHeader, proxy }) => {
         *      proxy('origin')
         *      setUpstreamResponseHeader('x-0-surrogate-key', 'proxy=origin')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param value The value to set
         */
        this.setUpstreamResponseHeader = (name, value) => {
            const validate = name.toLowerCase() != constants_1.HTTP_HEADERS.x0SurrogateKey;
            return this.internalSetResponseHeader(name, value, validate, this.preCacheResponseActions);
        };
        /**
         * Alters an upstream response header before attempting to cache the response.
         * Use this method to derive the new header value from the existing one.
         * In local development this is same as calling `updateResponseHeader` but on
         * edge it updates a header immediately after the upstream fetch has finished.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateUpstreamResponseHeader, proxy }) => {
         *      proxy('origin')
         *      updateUpstreamResponseHeader('cache-control', /public/gi, 'private')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the response header
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateUpstreamResponseHeader = (name, match, replace) => {
            return this.internalUpdateResponseHeader(name, match, replace, this.preCacheResponseActions);
        };
        /**
         * Removes a response header before attempting to cache the response.
         * In local development this is same as calling `updateUpstreamResponseHeader` but
         * on edge it removes a header immediately after the upstream fetch has finished.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ removeUpstreamResponseHeader, proxy }) => {
         *      proxy('origin')
         *      removeUpstreamResponseHeader(HTTP_HEADERS.setCookie)
         *    })
         * ```
         * @param name The case-insensitive name of the response header
         */
        this.removeUpstreamResponseHeader = (name) => {
            return this.internalRemoveResponseHeader(name, this.preCacheResponseActions);
        };
        /**
         * Adds or replaces a request header.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ setRequestHeader, proxy }) => {
         *      setRequestHeader('some-header', 'some-value')
         *      proxy('origin')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the request header
         * @param value The value to set
         */
        this.setRequestHeader = (name, value) => {
            validateWriter_1.validateSetRequestHeader(name);
            this.scheduleExecution(this.postCacheRequestActions, () => {
                this.request.headers[name.toLowerCase()] = value;
            });
        };
        /**
         * Keeps count of the number of times we have started to execute any
         * workload immediately. When the counter is at zero, we are not in
         * the immediate execution mode.
         */
        this.runImmediatelyDepthCounter = 0;
        /**
         * Runs the given callback immediately, switching the response writer object
         * into immediate execution mode.
         *
         * @param callback
         */
        this.runImmediately = async (callback) => {
            try {
                ++this.runImmediatelyDepthCounter;
                await callback();
            }
            finally {
                --this.runImmediatelyDepthCounter;
            }
        };
        /**
         * Either schedules the action for the later execution or, when running immediately,
         * executes it right away.
         *
         * @param phase Array of Functions belonging to the specific execution phase (pre-cache request, post-cache request, etc)
         * @param action Action to be executed either immediately or put into the execution array
         */
        this.scheduleExecution = (phase, action) => {
            if (this.runningImmediately) {
                action();
            }
            else {
                phase.push(action);
            }
        };
        /**
         * Alters a request header. Use this method to derive the new header value from the existing one.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ updateRequestHeader, proxy }) => {
         *      updateRequestHeader('some-header', /some-.*-part/gi, 'some-replacement')
         *      proxy('origin')
         *    })
         * ```
         *
         * @param name The case-insensitive name of the request header
         * @param match Regex to find the part that should be replaced.
         * @param replace Value that will replace the matched part.
         */
        this.updateRequestHeader = (name, match, replace) => {
            validateWriter_1.validateUpdateRequestHeader(name);
            this.scheduleExecution(this.postCacheRequestActions, () => {
                const key = name.toLowerCase();
                const currentValue = this.request.headers[key];
                const interpolatedReplace = this.interpolateParams(replace);
                if (Array.isArray(currentValue)) {
                    this.request.headers[key] = currentValue.map(v => v.replace(match, interpolatedReplace));
                }
                else if (currentValue) {
                    this.request.headers[key] = currentValue.replace(match, interpolatedReplace);
                }
            });
        };
        /**
         * Removes a request header.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', async ({ removeRequestHeader, proxy }) => {
         *      removeRequestHeader('some-header')
         *      proxy('origin')
         *    })
         * ```
         * @param name The case-insensitive name of the request header
         */
        this.removeRequestHeader = (name) => {
            validateWriter_1.validateRemoveRequestHeader(name);
            this.scheduleExecution(this.postCacheRequestActions, () => {
                delete this.request.headers[name.toLowerCase()];
            });
        };
        /**
         * Returns the service worker with proper edge and browser cache headers
         * @param path The path to the service worker relative to the root directory of your app
         *
         * **Example**
         *
         * ```js
         *  new Router()
         *    .get('/service-worker.js', ({ serviceWorker }) => {
         *      serviceWorker('dist/service-worker.js')
         *    })
         * ```
         */
        this.serviceWorker = (path) => {
            this.cache({
                edge: {
                    maxAgeSeconds: 30758400,
                },
                browser: {
                    // It is critical that the service worker is never cached in the browser or it may never update.
                    // This can be catastrophic if a broken service worker is installed since it can prevent the site
                    // from being accessed at all
                    maxAgeSeconds: 0,
                },
            });
            this.serveStatic(path);
        };
        /**
         * Serves an HTML app shell from a static file.
         * @param indexHtmlPath The path to the app shell html file
         *
         * **Example**
         *
         * ```js
         *  new Router()
         *    .fallback(({ appShell }) => {
         *      appShell('dist/index.html')
         *    })
         * ```
         */
        this.appShell = (indexHtmlPath) => {
            this.setResponseHeader(constants_1.HTTP_HEADERS.contentType, 'text/html');
            this.serveStatic(indexHtmlPath);
        };
        /**
         * Sends the necessary response headers to allow CORS
         * @param config
         *
         * **Example**
         *
         * ```js
         *  new Router()
         *    .match('/api/:path*', ({ allowCors }) => {
         *      allowCors({
         *        origin: '*', // this is the default
         *        methods: ['get', 'post'],
         *        headers: ['x-some-header'],
         *        maxAge: 60 * 60, // one hour
         *        credentials: true
         *      })
         *    })
         * ```
         */
        this.allowCors = (config = {}) => {
            this.setResponseHeader('Access-Control-Allow-Origin', config.origin || '*');
            if (config.methods) {
                this.setResponseHeader('Access-Control-Allow-Methods', config.methods.join(', '));
            }
            if (config.headers) {
                this.setResponseHeader('Access-Control-Allow-Headers', config.headers.join(', '));
            }
            if (config.maxAge) {
                this.setResponseHeader('Access-Control-Max-Age', config.maxAge.toString());
            }
            if (config.credentials != null) {
                this.setResponseHeader('Access-Control-Allow-Credentials', config.credentials.toString());
            }
        };
        /**
         * Sends content back to client. If content is a string, the respons will be sent
         * directly from the edge. If it is a function, the request will be computed by a JavaScript worker.
         *
         * **Example**
         *
         * ```
         *  new Router()
         *    .get('/some/path', ({ send }) => {
         *      return send('<html><body>Hello World!</body></html>', 200, 'OK')
         *    })
         * ```
         * @param content The response body as a string
         * @param statusCode The status to send
         * @param statusMessage The status message to send
         */
        this.send = (content, statusCode = 200, statusMessage) => {
            this.setCreateResponseAction(async () => {
                this.response.statusCode = statusCode;
                this.response.statusMessage = statusMessage;
                if (typeof content === 'function') {
                    this.response.body = content();
                }
                else {
                    this.response.body = content;
                }
            });
        };
        /**
         * Execute the provided callback function in the cloud. The callback is passed the request and the response.
         *
         * Use this method when you need to compute a response in the cloud rather than at the edge or at build time. A common example
         * is when the response must be computed based on request parameters, headers, or cookies.
         *
         * A common example is to look up the destination for a redirect from an external API:
         *
         * ```js
         *  new Router()
         *    .get('/products/:id', ({ redirect, compute }) => {
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        redirect(destination)
         *      })
         *    })
         * ```
         *
         * This method can be combined with `cache` to compute responses in the cloud and cache them at edge:
         *
         * ```js
         *  new Router()
         *    .get('/products/:id', ({ cache, redirect, compute }) => {
         *      cache({
         *        edge: {
         *          maxAgeSeconds: 60 * 60 * 24,
         *          staleWhileRevalidateSeconds: 60 * 60,
         *        }
         *      })
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        redirect(destination)
         *      })
         *    })
         * ```
         *
         * Note: when calling `compute` in combination with `serveStatic`, the result of the `serveStatic` must be
         * awaited in order to get the result from `serveStatic`, otherwise only reslut of the `compute` method
         * will be returned.
         *
         * ```js
         * new Router()
         *   .get('/products/:id', ({ redirect, compute }) => {
         *      compute(async (request, response) => {
         *        const destination = await getDestinationFromAPI(request.params.id)
         *        await serveStatic(destination)
         *      })
         *    })
         * ```
         *
         * @param callback A function to run in the cloud to compute the response
         */
        this.compute = (callback) => {
            this.setCreateResponseAction(async () => {
                // We need to clear createResponseAction because the compute callback will likely send it's own response
                // If we don't clear createResponseAction, setCreateResponseAction will throw a validation error which prevents multiple responses from being sent
                await this.clearResponseAction().runImmediately(() => callback(this.request, this.response));
            });
        };
        /**
         * Send json error response to client
         * @private
         * @param err
         */
        this.onRouteError = (err) => {
            let errorResponse = {
                status: 'error',
                message: err.message,
            };
            // Some errors are marked as user errors. We log those for higher visibility.
            const isUserError = err.isUserError;
            if (isUserError) {
                console.error(`${logo_1.errorLogLabel} ${err.message}`);
            }
            if (process.env.NODE_ENV !== 'production') {
                errorResponse = {
                    message: `An error occured while running route ${this.route.toString()}: ${err.message}`,
                    // We don't send the stack for user errors as they are raised from our code
                    // but indicate issues in user's code.
                    stack: !isUserError ? err.stack : undefined,
                    url: this.request.url,
                };
            }
            try {
                this.response.setHeader(constants_1.HTTP_HEADERS.contentType, 'application/json');
                this.response.writeHead(500);
                this.response.end(JSON.stringify(errorResponse));
            }
            catch (e) {
                console.error(`${logo_1.errorLogLabel} Could not write error response because headers have already been sent.`, errorResponse);
            }
        };
        this.request = req;
        this.response = res;
        this.route = route;
        this.context = context;
    }
    /**
     * Called at the end of the request to send the response back to the browser. Methods like proxy,
     * serveStatic, and render will replace this method with one that actually sends a response.
     * @private
     * @returns True if there send response was defined and invoked, otherwise false.
     */
    async sendResponse({ beforeResponse = () => true } = {}) {
        let sendResponse = false;
        for (let action of this.preCacheRequestActions) {
            action();
        }
        let cachedResponse, cacheKey;
        if (Cache_1.isCacheEnabled()) {
            cacheKey = this.context.cacheKey || CacheKey_1.default.create(this.request, this.cacheKey);
            cachedResponse = Cache_1.getCachedResponse(cacheKey);
            if (this.cacheKey) {
                // we put the custom cache key on the context so that it can be used by a later route which generates the response.  This is common, for example, with Next and Nuxt apps, which generate response via middleware.
                this.context.cacheKey = cacheKey;
            }
            if (!this.validatePrefetch(cachedResponse)) {
                console.log(`${logo_1.infoLogLabel} throttle ${this.request.url}`);
                return true;
            }
        }
        if (cachedResponse) {
            sendResponse = true;
            new timing_1.InternalTiming(timing_1.InternalNames.edgeCache).set(timing_1.CacheValue.hit);
            this.applyCachedResponse(cachedResponse);
        }
        else {
            for (let action of this.postCacheRequestActions) {
                action();
            }
            if (this.createResponseAction) {
                await this.createResponseAction();
                sendResponse = true;
            }
            for (let action of this.preCacheResponseActions) {
                action();
            }
            // This will evaluate the error routes based on the received status code.
            // When this finds a match it will return that response was sent. That means
            // That before response did take care of the response and issued a paged matching the error route.
            const shouldContinue = await beforeResponse(this.response);
            if (!shouldContinue) {
                return sendResponse;
            }
        }
        if (sendResponse && !this.streaming && !cachedResponse && Cache_1.isCacheEnabled()) {
            const cached = Cache_1.maybeCacheResponse({
                response: this.response,
                // @ts-ignore - cacheKey can't actually be undefined here because it will be set if isCacheEnabled() is true
                cacheKey,
                context: this.context,
            });
            new timing_1.InternalTiming(timing_1.InternalNames.edgeCache).set(cached ? timing_1.CacheValue.cached : timing_1.CacheValue.pass);
        }
        for (let action of this.postCacheResponseActions) {
            action();
        }
        if (sendResponse && !this.streaming) {
            this.logCacheStatus();
            timing_1.addTimings(this.response);
            if (this.response.statusCode) {
                this.response.writeHead(this.response.statusCode, this.response.statusMessage || undefined);
            }
            this.response.end(this.response.body);
        }
        return sendResponse;
    }
    /**
     * Logs the cache status when running locally with caching is enabled
     */
    logCacheStatus() {
        if (Cache_1.isCacheEnabled()) {
            // for now we only add x-0-t when running with --cache because the only measurement we include is ecc=cached|pass|hit
            const status = this.response.getHeader(constants_1.HTTP_HEADERS.x0CachingStatus);
            const hitOrMiss = timing_1.getInternalTiming(timing_1.InternalNames.edgeCache);
            const { url } = this.request;
            console.log(`${logo_1.infoLogLabel} ${hitOrMiss} ${url}${status ? ` (${status})` : ''}`);
        }
    }
    /**
     * Copies the body, headers, and status from the cached response
     * to the outgoing response.
     * @param cachedResponse The cached response
     */
    applyCachedResponse(cachedResponse) {
        this.response.statusCode = cachedResponse.statusCode;
        this.response.statusMessage = cachedResponse.statusMessage;
        this.response.body = lodash_clonedeep_1.default(cachedResponse.body);
        for (let name of Object.keys(cachedResponse.headers)) {
            // We have to cloneDeep because some headers are arrays rather than just strings.
            this.response.setHeader(name, lodash_clonedeep_1.default(cachedResponse.headers[name]));
        }
    }
    /**
     * Rejects the request with status 412 and returns false if ?layer0_prefetch is present and
     * no cached response was found.
     */
    validatePrefetch(cachedResponse) {
        const isThrottled = Object.keys(this.request.query || {}).includes(constants_1.THROTTLED_QUERY_PARAM);
        if (isThrottled && !cachedResponse) {
            this.response.writeHead(constants_1.LAYER0_UNCACHED_PREFETCH_STATUS);
            this.response.end();
            return false;
        }
        else {
            return true;
        }
    }
    /**
     * @param action
     */
    async setCreateResponseAction(action) {
        if (this.runningImmediately) {
            await action();
        }
        else {
            if (this.createResponseAction != null) {
                throw new Error('You may only call one of the following once in your route handler: proxy, serveStatic, serviceWorker, redirect, send.');
            }
            this.createResponseAction = action;
        }
    }
    /**
     * Returns true if the object is in the running immediately mode.
     * When object is in the running immediately mode, all otherwise
     * scheduled actions like header transform operations, are immediately
     * executed.
     * @private
     */
    get runningImmediately() {
        return this.runImmediatelyDepthCounter > 0;
    }
    /**
     * Clears response action. This is required for compute and error pages. Error pages must alter the initial response and execute the error routes separately.
     *
     * @private
     * @returns
     */
    clearResponseAction() {
        this.createResponseAction = undefined;
        return this;
    }
}
exports.default = ResponseWriter;
/**
 * @private
 * @param backendConfig
 */
function normalizeBackendConfig(backendConfig) {
    if (typeof backendConfig === 'string')
        backendConfig = { domainOrIp: backendConfig };
    return backendConfig;
}
