"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cookie_1 = __importDefault(require("cookie"));
const querystring_1 = require("querystring");
const identity_1 = __importDefault(require("../utils/identity"));
/**
 * @private
 * Emulates the edge by interpolating header values
 *
 * Note: This code must be kept in sync with the interpolateParams: values from ECL compiler
 *
 * Supported interpolation strings are:
 *  - ${method}: the request method GET/PUT/POST/etc...
 *  - ${path}: the return path without query parameters
 *  - ${url}: the original unmodified request url
 *  - ${req:<request header name>}: a request header value
 *  - ${req:cookie:<request cookie name>}: a request cookie value
 *  - ${res:<response header name>}: a response header value
 *
 * @param req The request
 * @param res The response
 * @param value The string or array of strings to interpolate
 */
function interpolateParams(req, res, value) {
    if (typeof value === 'string') {
        return interpolateParam(req, res, value);
    }
    if (!Array.isArray(value)) {
        // Skip any non-string and non-string array values
        return value;
    }
    const results = [];
    value.forEach(v => {
        results.push(interpolateParams(req, res, v));
    });
    return results;
}
exports.default = interpolateParams;
/**
 * @private
 * Interpolates a single string value
 *
 *  NOTE: We emulate the Fastly Edge closely, but there are known difference. E.g. if you have header='hi ${req:cookie:test}' and there is no
 *        cookie name 'test' Fastly will return header='hi (null)' but if you have header='${req:cookie:test}' Fastly will drop the header.
 *        This interpolator just returns '' for not found values.
 * @param req The request
 * @param res The response
 * @param value a string to interpolate
 */
function interpolateParam(req, res, value) {
    // We can have multiple replacements per value, so we need to loop through all the possible cases
    // Use '--backslashdollar--' so we do not interpret '\${' in the results.
    // Use '--separator--' so we keep the '${' in the results of split().
    const segments = value
        .replace(/\\\${/g, '--backslashdollar--')
        .replace(/\${/g, '--separator--${')
        .split('--separator--');
    // Parse cookies once at the top of the function as an optimization
    let cookies = {};
    if (req === null || req === void 0 ? void 0 : req.headers.cookie) {
        // Pass in the 'do nothing' decode function to return the cookie value without decoding it
        cookies = cookie_1.default.parse(req.headers.cookie, { decode: identity_1.default });
    }
    // Parse query parameters once at the top of the function as an optimization
    let qs = {};
    if (req === null || req === void 0 ? void 0 : req.url) {
        const queryParameterIndex = req.url.indexOf('?');
        if (queryParameterIndex >= 0) {
            const queryParameters = req.url.substring(queryParameterIndex + 1);
            qs = querystring_1.parse(queryParameters);
        }
    }
    const interpolatedResults = [];
    const requestPrefixLength = '${req:'.length;
    const queryPrefixLength = '${query:'.length;
    segments.forEach(segment => {
        if (req) {
            segment = segment.replace(/\${method}/, req.method);
            segment = segment.replace(/\${path}/, req.path);
            segment = segment.replace(/\${url}/, req.url);
            // ${query:paramName} returns the found query parameter
            const startQueryParameterIndex = segment.search(/\${query:/);
            if (startQueryParameterIndex >= 0) {
                let queryParameterName = segment.substring(startQueryParameterIndex + queryPrefixLength);
                const endQueryParameterIndex = queryParameterName.indexOf('}');
                if (endQueryParameterIndex <= 0) {
                    throw new Error(`Cannot interpolate substring "${segment}" of value "${value}" (1)`);
                }
                queryParameterName = queryParameterName.substring(0, endQueryParameterIndex);
                // When there are multiple matches for the query parameter's name, we emulate
                // the edge's behavior and return the first match only.
                let queryReplacementString = qs[queryParameterName] || '';
                if (Array.isArray(queryReplacementString)) {
                    queryReplacementString = queryReplacementString[0];
                }
                segment = segment.replace(/\${query:.*?}/, queryReplacementString);
            }
            const startRequestIndex = segment.search(/\${req:/);
            if (startRequestIndex >= 0) {
                let requestHeaderName = segment.substring(startRequestIndex + requestPrefixLength);
                const endRequestIndex = requestHeaderName.indexOf('}');
                if (endRequestIndex <= 0) {
                    throw new Error(`Cannot interpolate substring "${segment}" of value "${value}" (2)`);
                }
                requestHeaderName = requestHeaderName.substring(0, endRequestIndex);
                let replacementString = '';
                // req:cookie:<key> injects the value of cookie named <key> or an empty string if <key> not found
                if (requestHeaderName.indexOf('cookie:') === 0) {
                    const cookieName = requestHeaderName.split(':')[1];
                    replacementString = cookies[cookieName] || '';
                    // req:param:<name> injects the value of named parameter <name> or an empty string if <name> not found
                }
                else if (requestHeaderName.indexOf('param:') === 0) {
                    const paramName = requestHeaderName.split(':')[1];
                    if (req.params && req.params[paramName]) {
                        replacementString = String(req.params[paramName]);
                    }
                    // req:<header>
                }
                else {
                    // Use an empty string if the request header is not found
                    replacementString = req.headers[requestHeaderName] || '';
                }
                segment = segment.replace(/\${req:.*?}/, replacementString);
            }
        }
        const startResponseIndex = segment.search(/\${res:/);
        if (startResponseIndex >= 0) {
            if (!res) {
                throw new Error(`Cannot interpolate response parameter "${segment}" during receive phase`);
            }
            let responseHeaderName = segment.substring(startResponseIndex + requestPrefixLength);
            const endResponseIndex = responseHeaderName.indexOf('}');
            if (endResponseIndex <= 0) {
                throw new Error(`Cannot interpolate substring "${segment}" of value "${value}" (3)`);
            }
            responseHeaderName = responseHeaderName.substring(0, endResponseIndex);
            segment = segment.replace(/\${res:.*?}/, res.getHeader(responseHeaderName) || '');
        }
        // If no replacement was done, we assume the <key> in ${<key>} was not valid and throw an error
        if (segment.search(/\${/) >= 0) {
            throw new Error(`Cannot interpolate substring "${segment}" of "${value}" (4)`);
        }
        interpolatedResults.push(segment);
    });
    return interpolatedResults.join('').replace(/--backslashdollar--/g, '${');
}
