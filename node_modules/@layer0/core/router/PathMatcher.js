"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_to_regexp_1 = require("path-to-regexp");
/**
 * Error class thrown by PathMatcher class.
 */
class PathMatcherError extends Error {
    constructor(pattern) {
        super(`Route pattern "${pattern}" contains invalid syntax. See https://docs.layer0.co/guides/routing#section_route_pattern_syntax`); // istanbul ignore next - this is a known issue with TypeScript
        this.isUserError = true;
    }
}
exports.PathMatcherError = PathMatcherError;
/**
 * @private
 * A simple abstraction of path-to-regexp that makes the process of
 * extracting variables from requests paths repeatable across multiple use cases
 * such as matching a route and rewriting params.
 */
class PathMatcher {
    /**
     * A path param in path-to-regexp syntax
     * @param pattern
     */
    constructor(pattern) {
        this.pattern = pattern;
    }
    /**
     * Returns key/value pairs if the path matches the pattern, otherwise undefined
     * @param path
     */
    match(path) {
        if (!this.matcher) {
            try {
                this.matcher = path_to_regexp_1.match(this.pattern, { decode: decodeURIComponent });
            }
            catch (e) {
                throw new PathMatcherError(this.pattern);
            }
        }
        PathMatcher.validatePattern(this.pattern);
        const result = this.matcher(path);
        return result ? result.params : undefined;
    }
    /**
     * Validate the given pattern as acceptable. If it's not acceptable an exception is raised
     * with sufficient information to fix the problem.
     *
     * Notes:
     * - Partial splat patterns (e.g. `/partial-:splat*`) have both semantic and execution issues.
     * Semantic issues lie in the fact that path-to-regexp will generate a surprisingly different
     * regexp for partial splat vs full splat pattern (e.g. `/full/:splat*`) that will actually not
     * match all the sub-paths that follow the partial prefix but rather only the rest of the path
     * until the end of the string. Execution issues lie in the fact that such regexes have been
     * observed to block Chrome, Node and other regular expression engines. To prevent issues with
     * these patterns we do not support them but propose a reasonable alternative of splitting the
     * splat into fixed and splat parameters.
     */
    static validatePattern(pattern) {
        const partialSplatRouteMatch = pattern.match(this.PARTIAL_SPLAT_ROUTE);
        if (partialSplatRouteMatch) {
            const [_, prefix, splat] = partialSplatRouteMatch;
            const alternativePattern = pattern.replace(`${prefix}${splat}`, `${prefix}:suffix/${splat}`);
            throw new PathMatcherError(`Partial splat routes are not supported. Use "${alternativePattern}" instead of "${pattern}"`);
        }
        return true;
    }
}
exports.default = PathMatcher;
/**
 * Matches partial splat (e.g. `/partial-:splat*`) routes.
 */
PathMatcher.PARTIAL_SPLAT_ROUTE = /(\/[^:/]+)(:[^*/#?]+\*)/;
