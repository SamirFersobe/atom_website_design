"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = __importDefault(require("url"));
const querystring_1 = __importDefault(require("querystring"));
/**
 * @private
 * Having a no-op BaseResponseWriter makes it easy for us to stub out the writer
 * when introspecing the router.  This is needed to implement Router.getPrefetchableRoutes
 */
class BaseResponseWriter {
    constructor(req, res, route) { }
    cache(options) { }
    redirect(to, options) { }
    /**
     * Translates redirect params into normalized version that solves backward compatibility
     * issues and also takes into account query parameters that may be included in the query
     * string itself.
     *
     * @param to string to where we are redirecting the request; may have query string
     * @param options options with which we are redirecting the request
     */
    _readRedirectParams(to, options) {
        const { statusCode = 302, query = {} } = 
        // Retro-compatibility, second argument used to be statusCode
        typeof options === 'number' ? { statusCode: options } : options;
        // Parse `to` param to extract query strings from it.
        let toQuery = {};
        const parsedTo = url_1.default.parse(to);
        // istanbul ignore next - ?. gives istanbul indigestion
        if (parsedTo === null || parsedTo === void 0 ? void 0 : parsedTo.search) {
            to = to.substr(0, to.length - parsedTo.search.length);
            // @ts-ignore: whenever search is truthy query is at least an empty string
            toQuery = querystring_1.default.parse(parsedTo.query);
        }
        return {
            to,
            statusCode,
            query: {
                ...toQuery,
                ...query,
            },
        };
    }
    proxy(backend, options) { }
    render(cb) { }
    stream(backend) { }
    serveStatic(path, options) { }
    updatePath(destination) { }
    rewrite(destination, pattern) { }
    setRequestHeader(name, value) { }
    updateRequestHeader(name, match, replace) { }
    removeRequestHeader(name) { }
    setUpstreamResponseHeader(name, value) { }
    updateUpstreamResponseHeader(name, match, replace) { }
    removeUpstreamResponseHeader(name) { }
    /*
     * JWTs are only verified on the edge, not locally or on the user lambda
     * implementation here is empty in ResponseWriter as here, and overwritten
     * with some bejaviour in EdgeResponseWriter
     */
    verifyJwt(options) { }
    setResponseHeader(name, value) { }
    updateResponseHeader(name, match, replace) { }
    removeResponseHeader(name) { }
    addResponseCookie(name, value, options) { }
    updateResponseCookie(name, match, replace) { }
    removeResponseCookie(name) { }
    addUpstreamResponseCookie(name, value, options) { }
    updateUpstreamResponseCookie(name, match, replace) { }
    removeUpstreamResponseCookie(name) { }
    send(content, statusCode, statusMessage) { }
    compute(callback) { }
    serviceWorker(path) { }
    allowCors(options) { }
    appShell(indexHtmlPath) { }
    renderWithApp(options) { }
}
exports.BaseResponseWriter = BaseResponseWriter;
