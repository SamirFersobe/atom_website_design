/**
 * Error class thrown by PathMatcher class.
 */
export declare class PathMatcherError extends Error {
    /**
     * Indicates that the error is user error and that it should be handled as so.
     */
    readonly isUserError: boolean;
    constructor(pattern: string);
}
/**
 * @private
 * A simple abstraction of path-to-regexp that makes the process of
 * extracting variables from requests paths repeatable across multiple use cases
 * such as matching a route and rewriting params.
 */
export default class PathMatcher {
    private readonly pattern;
    private matcher?;
    /**
     * A path param in path-to-regexp syntax
     * @param pattern
     */
    constructor(pattern: string);
    /**
     * Returns key/value pairs if the path matches the pattern, otherwise undefined
     * @param path
     */
    match(path: string): {
        [key: string]: string | string[];
    } | undefined;
    /**
     * Matches partial splat (e.g. `/partial-:splat*`) routes.
     */
    private static PARTIAL_SPLAT_ROUTE;
    /**
     * Validate the given pattern as acceptable. If it's not acceptable an exception is raised
     * with sufficient information to fix the problem.
     *
     * Notes:
     * - Partial splat patterns (e.g. `/partial-:splat*`) have both semantic and execution issues.
     * Semantic issues lie in the fact that path-to-regexp will generate a surprisingly different
     * regexp for partial splat vs full splat pattern (e.g. `/full/:splat*`) that will actually not
     * match all the sub-paths that follow the partial prefix but rather only the rest of the path
     * until the end of the string. Execution issues lie in the fact that such regexes have been
     * observed to block Chrome, Node and other regular expression engines. To prevent issues with
     * these patterns we do not support them but propose a reasonable alternative of splitting the
     * splat into fixed and splat parameters.
     */
    private static validatePattern;
}
