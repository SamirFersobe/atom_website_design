"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Route_1 = __importDefault(require("./Route"));
const Cache_1 = require("../cache/Cache");
const environment_1 = require("../environment");
const path_1 = require("path");
const nonWebpackRequire_1 = __importDefault(require("../utils/nonWebpackRequire"));
const normalizeCriteria_1 = __importDefault(require("./normalizeCriteria"));
const constants_1 = require("../constants");
const source_1 = require("../source");
const slash_1 = __importDefault(require("slash"));
const requireInternal_1 = __importDefault(require("../utils/requireInternal"));
/**
 * The contents to be written to static-asset-manifest.json
 * @private
 */
exports.staticAssetManifest = {};
/**
 * The static asset manifest file name
 * @private
 */
exports.STATIC_ASSET_MANIFEST_FILE = 'static-asset-manifest.json';
/**
 * This class is needed for creating a route group that holds a routes that can
 * be dynamically updated on a local env.
 * @private
 */
class RouteGroup {
    /**
     * @param name Name of the route group - **required**
     */
    constructor(name) {
        this._routes = [];
        if (!name) {
            throw new Error('Route group name is required!');
        }
        this.name = name;
    }
    /**
     * Adds route to group.
     * @param criteria The criteria to match.
     * @param handler The handler to use for the route.
     */
    match(criteria, handler, { index, label } = {}) {
        const route = new Route_1.default(criteria, handler, { label });
        if (index != null) {
            this._routes.splice(index, 0, route);
        }
        else {
            this._routes.push(route);
        }
        return this;
    }
    /**
     * Adds routes for all files in a directory tree.
     * @private
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    dir(sourcePath, options) {
        const directory = path_1.join(source_1.getSourceDir(), sourcePath);
        const manifest = (exports.staticAssetManifest[slash_1.default(sourcePath)] = []); // we normalize paths to use "/" here in case the user is building on windows but running on Linux
        let { ignore, label } = options;
        if (typeof ignore === 'string') {
            ignore = [ignore];
        }
        let files = environment_1.isCloud()
            ? this.staticAssetsForPath(sourcePath)
            : requireInternal_1.default('globby').sync(options.glob || '**/*', {
                // glob is large and we don't need it in production so we use nonWebpackRequire
                cwd: directory,
                onlyFiles: true,
                ignore: ignore || [],
            });
        if (options.sort) {
            files = options.sort(files);
        }
        for (let file of files) {
            const paths = (options.paths && options.paths(file)) || [`/${file}`];
            if (!environment_1.isCloud()) {
                manifest.push(slash_1.default(file)); // we normalize paths to use "/" here in case the user is building on windows but running on Linux
            }
            for (let path of paths) {
                let route = path.replace(/\/index.html$/, '');
                if (route.length === 0) {
                    route = '/';
                }
                this.match(route, async (res) => {
                    options.handler && options.handler(file)(res);
                }, { label });
            }
        }
        return this;
    }
    /**
     * Adds routes for all static assets in a directory tree.
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath, options) {
        const handler = (file) => (res) => {
            if (options.handler) {
                options.handler(file)(res);
            }
            res.serveStatic(`${sourcePath}/${file}`);
        };
        return this.dir(sourcePath, { ...options, handler, label: `static('${sourcePath}')` });
    }
    /**
     * Adds Basic Authentication.
     *
     * **example**
     *
     * ```js
     *  router
     *    .requireBasicAuth({ username: 'user', password: 's3cr3t!' })
     *    // ...include additional routes below...
     * ```
     *
     * You can also require basic auth for a subset of URLs using the criteria option:
     *
     * ```js
     *  router
     *    .requireBasicAuth({ criteria: '/secret/:path*' username: 'user', password: 's3cr3t!' })
     *    // ...include additional routes below...
     * ```
     *
     * The criteria option accepts a path pattern as a string, or a RouteCriteria object.
     *
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    requireBasicAuth(options) {
        let { route, username, password, realm = 'Access to the site' } = options;
        if (username && password) {
            const token = Buffer.from(`${username}:${password}`).toString('base64');
            route = normalizeCriteria_1.default(route);
            // Add route handlers that will return 401, 403 or remove the authorizaton header,
            // depending on the request properties.
            // We run these handlers only if they have not already run in the edge. To detect this
            // we cannot use `x-0-version` header because it gets injected very early in the edge
            // so by the time the router matching runs, it's already present. We also cannot use
            // `x-0-lambda-name` header because it gets removed by XBP before it reaches the lambda.
            // We use `x-0-matched-routes` as the definitive indicator that a router has ran before
            // the traffic reached this router.
            this
                // Provide challenge when the Authorization header is not present.
                .match({
                ...route,
                headers: {
                    ...route.headers,
                    [constants_1.HTTP_HEADERS.authorization]: null,
                    [constants_1.HTTP_HEADERS.x0MatchedRoutes]: null,
                },
            }, ({ send, setResponseHeader }) => {
                setResponseHeader('WWW-Authenticate', `Basic realm="${realm}"`);
                send('', 401, 'Unauthorized');
            })
                // Block the request when the Authorization header is not matching the basic auth token.
                .match({
                ...route,
                headers: {
                    ...route.headers,
                    [constants_1.HTTP_HEADERS.authorization]: new RegExp(`^((?!Basic ${token}).)*$`),
                    [constants_1.HTTP_HEADERS.x0MatchedRoutes]: null,
                },
            }, ({ send }) => {
                send('', 403, 'Forbidden');
            })
                // Do not leak authorization header upstream as upstreams are not likely to recognize it
                // and are free to block the request.
                .match({
                ...route,
                headers: {
                    ...route.headers,
                    [constants_1.HTTP_HEADERS.x0MatchedRoutes]: null,
                },
            }, ({ removeRequestHeader }) => {
                removeRequestHeader('authorization');
            });
        }
        return this;
    }
    /**
     * Since the files are now on S3, we can no longer crawl the file system to
     * determine the routes, so we use the manifest file.
     * We also prevent webpack from trying to bundle the manifest, which will fail.
     */
    staticAssetsForPath(path) {
        return nonWebpackRequire_1.default(path_1.join(process.cwd(), exports.STATIC_ASSET_MANIFEST_FILE))[path];
    }
    /**
     * Clears all routes in group.
     * Used for updating routes dynamically for development purpose.
     */
    clear() {
        this._routes = [];
        if (!environment_1.isCloud()) {
            Cache_1.clearCache();
        }
        return this;
    }
    /**
     * Returns the routes in group.
     * @returns Routes in group
     */
    get routes() {
        return this._routes;
    }
    /**
     * Returns number of routes in group.
     * @returns Number of routes in the group.
     */
    get length() {
        return this._routes.length;
    }
}
exports.default = RouteGroup;
