"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const path_1 = require("path");
const BackendFetchError_1 = __importDefault(require("../errors/BackendFetchError"));
const mergeQueryString_1 = __importDefault(require("./mergeQueryString"));
const constants_1 = require("../constants");
/**
 * Array of response headers that will not be passed over directly from the proxied resource
 *
 * Notes:
 * - transfer-encoding: as it poisons the response which will be formed
 * based on its own transfer-encoding rather than the one received from the Lambda.
 *
 * - content-length: as the actual constant may be changed by buffer proxy
 * (e.g. on moov_debug=true)
 * @private
 */
const IGNORE_RESPONSE_HEADERS = ['transfer-encoding', 'content-length'];
/**
 * @private
 */
class Backend {
    constructor(config) {
        this.config = config;
    }
    static setImpl(implementation) {
        impl = implementation;
    }
    static create(config) {
        return new impl(config);
    }
    /**
     * Sends a request using the proxy.
     * @param req The request being sent.
     * @param res The response for the request.
     */
    async fetch(req, res, options) {
        const { path, headers } = options || {};
        // Create url for proxy with query params added if existing
        const url = this.getProxyTarget(req, path);
        const requestOptions = this.getProxyRequestOptions(url, req, headers, options === null || options === void 0 ? void 0 : options.removeEmptySearchParamValues);
        return new Promise((resolve, reject) => {
            const lib = url.protocol === 'https:' ? https_1.default : http_1.default;
            const upstreamReq = lib.request(requestOptions, upstreamRes => {
                let buf = [];
                upstreamRes
                    .on('data', (chunk) => buf.push(chunk))
                    .on('end', () => {
                    /* istanbul ignore else */
                    if (upstreamRes.complete) {
                        Object.entries(upstreamRes.headers)
                            .filter(([name]) => !IGNORE_RESPONSE_HEADERS.includes(name.toLowerCase()))
                            .forEach(([name, value]) => {
                            try {
                                res.setHeader(name, value);
                            }
                            catch (e) {
                                console.warn(`Could not relay upstream response header ${name} with value ${value}`, e);
                            }
                        });
                        res.statusCode = upstreamRes.statusCode;
                        res.statusMessage = upstreamRes.statusMessage;
                        res.body = Buffer.concat(buf);
                        /* istanbul ignore if */
                        if (process.env.DEBUG === 'true') {
                            console.log('proxy', `[${res.statusCode} ${res.statusMessage}]`, url);
                        }
                        resolve(undefined);
                    }
                })
                    .on('error', 
                /* istanbul ignore next */ e => {
                    reject(new BackendFetchError_1.default(e));
                })
                    // Closing the connection before the response is complete
                    // has different behaviours depending on NodeJs version
                    // - node 12: triggers a 'close' event on the Request and Response, and an 'end' event on Response in between
                    // - node 14: triggers a 'close' event on the Request and Response, but no 'end' event on Response anymore
                    // - node 16: triggers a 'close' event on the Request and Response and an "aborted" error on Response in between
                    // See playground at https://runkit.com/adrien-k/aborted-res-error
                    //
                    // We take the most compatible approach, although in v16 and above this should be caught by the 'error' event.
                    /* istanbul ignore next */
                    .on('close', 
                /* istanbul ignore next */ () => {
                    if (!upstreamRes.complete) {
                        reject(new BackendFetchError_1.default(new Error('The connection was terminated while the message was still being sent')));
                    }
                });
            });
            upstreamReq.on('error', e => reject(new BackendFetchError_1.default(e)));
            upstreamReq.end(req.rawBody);
        });
    }
    /**
     * Returns proxy configuration for http-proxy
     * @returns proxy target url
     */
    getProxyTarget(req, path) {
        let url = path ? mergeQueryString_1.default(req.url, path) : req.url;
        const { domainOrIp, basePath, port } = this.config;
        if (basePath) {
            url = path_1.join(basePath, url);
        }
        /* istanbul ignore next */
        if (domainOrIp) {
            const protocol = domainOrIp.match(/^(127.0.0.1|localhost)(:\d+)?$/) ? 'http' : 'https';
            const domain = `${domainOrIp}${port ? `:${port}` : ''}`;
            url = `${protocol}://${path_1.join(domain, url)}`;
        }
        const parsed = url_1.parse(url, true);
        // Force insecure protocol if header is present
        if (req.getHeader(constants_1.HTTP_HEADERS.x0Protocol) === 'http') {
            parsed.protocol = 'http:';
        }
        return parsed;
    }
    /**
     * Returns true if the URL points to the local JS backend, otherwise false.
     * @param url
     * @returns
     */
    isLocal(url) {
        return url.hostname === constants_1.JS_BACKEND_HOSTNAME;
    }
    /**
     * Returns proxy configuration object for node-fetch
     * @param url
     * @param req
     * @param headers Additional request headers to include
     * @param removeEmptySearchParamValues If true, search param values that are empty are removed so "?foo=" becomes "?foo".
     */
    getProxyRequestOptions(url, req, headers, removeEmptySearchParamValues) {
        let agent = null;
        if (this.config.disableCheckCert && url.protocol === 'https:') {
            // For self signed cert fix on local development S3 bucket
            agent = new https_1.default.Agent({ rejectUnauthorized: false });
        }
        const upstreamHeaders = {
            ...req.headers,
            ...headers,
            host: this.config.hostHeader || req.headers.host,
        };
        if (this.isLocal(url)) {
            // Some libraries, like [is-https](https://github.com/unjs/is-https#behaviour), rely on x-forwarded-proto
            // to determine if the source request was made securely. This is notably used by Vue Storefront 2. Before
            // we added this header, API requests made by Vue Storefront 2 from the cloud would attempt to reenter Layer0
            // using an http POST, which would be redirected to an https GET, which would cause an infinite loop and soaring lambda costs.
            // Note that we only add x-forwarded-proto for local requests, which never happen over TLS. For remote requests, TLS is used
            // when the downstream request used TLS. We've chosen to do this in order to avoid altering the public behavior of Layer0, which
            // has never sent x-forwarded-proto to origins.
            upstreamHeaders['x-forwarded-proto'] = req.secure ? 'https' : 'http';
        }
        let path = url.path;
        if (removeEmptySearchParamValues === true && path) {
            path = path.replace(/=(?=&|$)/gm, '');
        }
        return {
            ...url,
            path,
            method: req.method,
            timeout: this.config.firstByteTimeout || 0,
            agent,
            body: req.rawBody,
            headers: upstreamHeaders,
        };
    }
}
exports.default = Backend;
let impl = Backend;
