"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const timing_1 = require("../timing");
const uuid_1 = require("uuid");
const addBuiltInRoutes_1 = __importDefault(require("./addBuiltInRoutes"));
const BehindEdgeResponseWriterProxy_1 = __importDefault(require("./BehindEdgeResponseWriterProxy"));
const config_1 = __importDefault(require("../config"));
const createEdgeConfig_1 = __importDefault(require("../edge/createEdgeConfig"));
const interpolateParams_1 = __importDefault(require("./interpolateParams"));
const minBy_1 = __importDefault(require("../utils/minBy"));
const PreloadRequests_1 = __importDefault(require("./PreloadRequests"));
const readRawBody_1 = __importDefault(require("../utils/readRawBody"));
const RequestContext_1 = __importDefault(require("./RequestContext"));
const ResponseWriter_1 = __importDefault(require("./ResponseWriter"));
const RouteGroup_1 = __importStar(require("./RouteGroup"));
const RouteGroupList_1 = __importDefault(require("./RouteGroupList"));
const BROTLI_ENCODING_REGEX = /\bbr\b/;
const GZIP_ENCODING_REGEX = /\bgzip\b/;
/**
 * A router.
 */
class Router {
    constructor(options = {
        excludeBuiltInRoutes: false,
        allowReqQueryDuplicates: false,
    }) {
        var _a;
        this.routeGroups = new RouteGroupList_1.default();
        this.preloadRequests = new PreloadRequests_1.default();
        this.plugins = [];
        this.destinations = {};
        this.nextRouterIndex = 0;
        /**
         * Index is used to determine the precedence of a router when routing rules
         * have not resolved to a specific destination. The router with the lowest
         * number wins.
         * @private
         *
         */
        this._index = 0;
        /**
         * Checks headers for validity and updates them as needed.
         *
         * Notes:
         * - If x-request-id is not present we generate it and later inject it into
         * the response.
         * - If accept-encoding includes gzip then we use it but eliminating everything else
         * as we don't support other encodings. If there is no gzip in accept-encoding
         * then we delete it entirely forcing upstream to return uncoded response.
         * - We emulate the edge router by injecting the same headers it injects:
         *    - x-0-client-ip
         *    - x-forwarded-for
         */
        this.processRequestHeaders = (req) => {
            if (!req.headers[constants_1.HTTP_HEADERS.xRequestId]) {
                this.newRequestId = uuid_1.v4();
                req.headers[constants_1.HTTP_HEADERS.xRequestId] = this.newRequestId;
            }
            // Normalize the accept encoding.
            let acceptEncoding = req.headers[constants_1.HTTP_HEADERS.acceptEncoding];
            if (typeof acceptEncoding === 'string') {
                const acceptGzipEncoding = GZIP_ENCODING_REGEX.test(acceptEncoding);
                const acceptBrotliEncoding = BROTLI_ENCODING_REGEX.test(acceptEncoding);
                // Connasence of algorithm and values with edge: when both gzip and br are acceptable
                // to the downstream, we normalize the accept-encoding and send them both to the upstream.
                if (acceptGzipEncoding && acceptBrotliEncoding) {
                    acceptEncoding = `${constants_1.GZIP_ENCODING}, ${constants_1.BROTLI_ENCODING}`;
                }
                else if (acceptGzipEncoding) {
                    acceptEncoding = constants_1.GZIP_ENCODING;
                }
                else if (acceptBrotliEncoding) {
                    acceptEncoding = constants_1.BROTLI_ENCODING;
                }
                else {
                    acceptEncoding = null;
                }
            }
            else {
                acceptEncoding = null;
            }
            if (acceptEncoding) {
                req.headers[constants_1.HTTP_HEADERS.acceptEncoding] = acceptEncoding;
            }
            else {
                delete req.headers[constants_1.HTTP_HEADERS.acceptEncoding];
            }
            // Append the our local address to the x-forwarded-for header. If x-forwarded-for does not exist, we create it.
            const connection = req.connection;
            let localAddress = '127.0.0.1'; // put a default in, in case the underlying environment does not provide Ip.
            if (connection && connection.remoteAddress) {
                localAddress = connection.remoteAddress;
                // By default we treat all local connections as if they were made on HTTPS.
                // We treat the request as HTTP only if the user sends the x-0-protocol or
                // they are running with cookie `local_layer0_emulate_http_protocol` set to `true`.
                if (req.headers[constants_1.HTTP_HEADERS.x0Protocol] !== 'http') {
                    const cookie = req.headers[constants_1.HTTP_HEADERS.cookie];
                    if (typeof cookie === 'string' &&
                        /\blocal_layer0_emulate_http_protocol=true\b/.test(cookie)) {
                        req.headers[constants_1.HTTP_HEADERS.x0Protocol] = 'http';
                    }
                    else {
                        req.headers[constants_1.HTTP_HEADERS.x0Protocol] = 'https';
                    }
                }
            }
            else {
                // Assume HTTPS request when not specified. This doesn't normally happen as downstream
                // components will have injected x-0-protocol by the time the Router is reached.
                // But in tests we often use plain objects for requests and directly send them to a Router.
                if (!req.headers[constants_1.HTTP_HEADERS.x0Protocol]) {
                    req.headers[constants_1.HTTP_HEADERS.x0Protocol] = 'https';
                }
            }
            if (req.headers[constants_1.HTTP_HEADERS.xForwardedFor]) {
                req.headers[constants_1.HTTP_HEADERS.xForwardedFor] = `${req.headers[constants_1.HTTP_HEADERS.xForwardedFor]}, ${localAddress}`;
            }
            else {
                req.headers[constants_1.HTTP_HEADERS.xForwardedFor] = `${localAddress}`;
            }
            if (!req.headers[constants_1.HTTP_HEADERS.x0ClientIp]) {
                // The client Ip is always the left most x-forwarded-for: value.
                req.headers[constants_1.HTTP_HEADERS.x0ClientIp] = (req.headers[constants_1.HTTP_HEADERS.xForwardedFor]).split(',')[0];
            }
            if (!Router.isRequestFromEdge(req)) {
                this.processRequestDeviceHeaders(req);
                this.processRequestGeoHeaders(req);
            }
        };
        /**
         * Emulates edge by injecting device headers into the request prior to routing.
         *
         * Notes:
         * - This code must be the same as the the generated edge router.
         * - This code has been directly translated from ECL compiler
         * - We emulate the edge router by injecting the same headers it injects:
         *    - x-0-device
         *    - x-0-vendor
         *    - x-0-browser
         *    - x-0-device-is-bot
         */
        this.processRequestDeviceHeaders = (req) => {
            let device = 'desktop';
            let vendor = 'generic';
            let isBot = false;
            let browser = 'generic';
            // Note: unlike outer-edge code, we transform everything to lower case for faster matching
            const ua = (req.headers[constants_1.HTTP_HEADERS.userAgent] || '').toLowerCase();
            if (/ipad/.test(ua)) {
                device = 'tablet';
                vendor = 'apple';
            }
            else if (/ip(hone|od)/.test(ua)) {
                device = 'smartphone';
                vendor = 'apple';
            }
            else if (/android.*(mobile|mini)/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/android/.test(ua)) {
                device = 'tablet';
                vendor = 'android';
            }
            else if (/opera mobi/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/playbook u rim tablet/.test(ua)) {
                device = 'tablet';
                vendor = 'blackberry';
            }
            else if (/hp-tablet.*touchpad/.test(ua)) {
                device = 'tablet';
                vendor = 'hp';
            }
            else if (/kindle\/3/.test(ua)) {
                device = 'tablet';
                vendor = 'kindle';
            }
            else if (/mobile.+firefox/.test(ua)) {
                device = 'mobile';
                vendor = 'firefoxos';
            }
            else if (/^htc/.test(ua)) {
                device = 'smartphone';
                vendor = 'htc';
            }
            else if (/fennec/.test(ua)) {
                device = 'smartphone';
                vendor = 'fennec';
            }
            else if (/iemobile/.test(ua)) {
                device = 'smartphone';
                vendor = 'microsoft';
            }
            else if (/blackberry/.test(ua) || /bb10.*mobile/.test(ua)) {
                device = 'smartphone';
                vendor = 'blackberry';
            }
            else if (/gt-.*build\/gingerbread/.test(ua)) {
                device = 'smartphone';
                vendor = 'android';
            }
            else if (/symbianos.*applewebkit/.test(ua)) {
                device = 'smartphone';
                vendor = 'symbian';
            }
            else if (/symbian/.test(ua) ||
                /^sonyericsson/.test(ua) ||
                /^nokia/.test(ua) ||
                /^samsung/.test(ua) ||
                /^lg/.test(ua) ||
                /bada/.test(ua) ||
                /blazer/.test(ua) ||
                /cellphone/.test(ua) ||
                // /iemobile/.test(ua) || duplicate - this case never hits because it matches above
                /midp-2.0/.test(ua) ||
                /u990/.test(ua) ||
                /netfront/.test(ua) ||
                /opera mini/.test(ua) ||
                /palm/.test(ua) ||
                /nintendo wii/.test(ua) ||
                /playstation portable/.test(ua) ||
                /portalmmm/.test(ua) ||
                /proxinet/.test(ua) ||
                /sonyericsson/.test(ua) ||
                // /symbian/.test(ua) || duplicate
                /windows ?ce/.test(ua) ||
                /winwap/.test(ua) ||
                /eudoraweb/.test(ua) ||
                // /htc/.test(ua) || duplicate
                /240x320/.test(ua) ||
                /avantgo/.test(ua)) {
                device = 'mobile';
            }
            if (/bot/.test(ua) ||
                /crawler/.test(ua) ||
                /headless/.test(ua) ||
                /prerender/.test(ua) ||
                /preview/.test(ua) ||
                /scanner/.test(ua) ||
                /slurp/.test(ua) ||
                /spider/.test(ua) ||
                /(developers.google.com\/+\/web\/snippet|embedly|facebookexternalhit|flipboard|googlepagespeed|google page speed)/.test(ua) ||
                /(ia_archiver|moov-prerender-cache-exerciser|nuzzel|outbrain|pinterest|qwantify|tumblr|vkshare)/.test(ua) ||
                /(w3c_validator|whatsapp|xing-contenttabreceiver|yahoo)/.test(ua)) {
                isBot = true;
            }
            else {
                isBot = false;
            }
            if (/edge/.test(ua)) {
                browser = 'edge';
            }
            else if (/chrome|chromium|crios/.test(ua)) {
                browser = 'chrome';
            }
            else if (/firefox/.test(ua)) {
                browser = 'firefox';
            }
            else if (/opera|opr/.test(ua)) {
                browser = 'opera';
            }
            else if (/msie/.test(ua) || /trident/.test(ua)) {
                browser = 'msie';
            }
            else if (/safari/.test(ua)) {
                browser = 'safari';
            }
            req.headers[constants_1.HTTP_HEADERS.x0Device] = device;
            req.headers[constants_1.HTTP_HEADERS.x0DeviceIsBot] = isBot ? '1' : '0';
            req.headers[constants_1.HTTP_HEADERS.x0Vendor] = vendor;
            req.headers[constants_1.HTTP_HEADERS.x0Browser] = browser;
        };
        /**
         * Emulates edge by injecting Geolocation headers into the request prior to routing.
         *  - x-0-geo-city
         *  - x-0-geo-country-code
         *  - x-0-geo-latitude
         *  - x-0-geo-longitude
         *  - x-0-geo-postal-code
         */
        this.processRequestGeoHeaders = (req) => {
            req.headers[constants_1.HTTP_HEADERS.x0GeoCity] = 'San Francisco';
            req.headers[constants_1.HTTP_HEADERS.x0GeoCountryCode] = 'US';
            req.headers[constants_1.HTTP_HEADERS.x0GeoLatitude] = '37.792094';
            req.headers[constants_1.HTTP_HEADERS.x0GeoLongitude] = '-122.401622';
            req.headers[constants_1.HTTP_HEADERS.x0GeoPostalCode] = '94104';
        };
        /**
         * Adds the `rawBody` (Buffer) and `body` (String) to the request
         * @param req
         */
        this.processRequestBody = async (req) => {
            req.rawBody = await readRawBody_1.default(req);
            Object.defineProperty(req, 'body', {
                configurable: true,
                get() {
                    return this.rawBody.toString('utf8');
                },
            });
        };
        /**
         * Checks if the number of user headers is within the limits.
         *
         * Notes:
         * - User headers are all those that do not have `x-0-` prefix.
         * - We check user headers counts in the router because in local
         * development the router is running on "the edge" and we want to
         * simulate the edge behavior (which actually has hard limits on
         * header count - see `LAYER0_MAX_USER_HEADERS_ALLOWED` for more info)
         */
        this.isUserHeaderCountWithinLimits = (headers) => {
            const userHeaderNames = Object.keys(headers).filter(name => name.toLowerCase().indexOf(constants_1.LAYER0_HEADERS_PREFIX) !== 0);
            return userHeaderNames.length <= constants_1.LAYER0_MAX_USER_HEADERS_ALLOWED;
        };
        /**
         * Patches writeHead method of the response so that we can do any post-response work.
         *
         * Notes:
         * - Injects response ID header when this same component has generated the request ID.
         * All components that actually generate the request ID before processing the request
         * or going upstream are then also responsible for sending back the request ID downstream.
         * - Return status 542 when there are too many response headers.
         *
         * @param req The request
         * @param res The response
         */
        this.patchResWriteHead = (req, res) => {
            const originalWriteHead = res.writeHead;
            res.writeHead = (...args) => {
                res.writeHead = originalWriteHead;
                if (this.newRequestId) {
                    res.setHeader(constants_1.HTTP_HEADERS.xRequestId, this.newRequestId);
                }
                const HEADERS_ARGS_INDEX = 2;
                const headers = args[HEADERS_ARGS_INDEX];
                if (headers) {
                    for (let key of Object.keys(headers)) {
                        res.setHeader(key, interpolateParams_1.default(req, res, headers[key]));
                    }
                }
                if (this.isUserHeaderCountWithinLimits(res.getHeaders())) {
                    res.writeHead(...args);
                    return;
                }
                res.writeHead(constants_1.LAYER0_TOO_MANY_HEADERS_STATUS_CODE, 'Too many response headers');
            };
        };
        /**
         * Handles a request, sending the response by running the handler for each matched route.
         * @param req The request
         * @param res The response
         */
        this.run = async (req, res) => {
            const routeMatchTime = new timing_1.InternalTiming(timing_1.InternalNames.routeMatching).start();
            let router = this;
            const context = new RequestContext_1.default();
            this.processRequestHeaders(req);
            if (!this.isUserHeaderCountWithinLimits(req.headers)) {
                res.writeHead(constants_1.LAYER0_TOO_MANY_HEADERS_STATUS_CODE, 'Too many request headers');
                res.end();
                return;
            }
            await this.processRequestBody(req);
            this.patchResWriteHead(req, res);
            if (Object.keys(this.destinations).length > 1) {
                const { LAYER0_ROUTER_DESTINATION } = process.env;
                let destinationName = ((req.headers[constants_1.HTTP_HEADERS.x0Destination] || LAYER0_ROUTER_DESTINATION));
                if (!destinationName) {
                    // Connascence of algorithm between @layer0/core and @layer0/build-lambda:
                    // when destination cannot be determined by other means, then
                    // we choose the first router that was added to the list.
                    destinationName = minBy_1.default(Object.keys(this.destinations), destinationName => {
                        return this.destinations[destinationName]._index;
                    });
                }
                router = this.destinations[destinationName];
                if (!router) {
                    throw new Error(`Routing destination "${destinationName}" not found.`);
                }
            }
            router.plugins.forEach(p => p.onRequest(req)); // this gives the plugin an opportunity to update the routes before the request is handled
            const createResponseWriter = (route) => {
                const writer = new ResponseWriter_1.default(req, res, route, context);
                return Router.isRequestFromEdge(req) ? BehindEdgeResponseWriterProxy_1.default.create(writer) : writer;
            };
            // Loop thru route groups routes
            const routes = router.routeGroups.getRoutes().filter(r => !r.isRespRoute());
            const errorRoutes = router.routeGroups.getRoutes().filter(r => r.isRespRoute());
            for (let route of routes) {
                let writer;
                try {
                    routeMatchTime.resume();
                    if (!route.match(req))
                        continue;
                    routeMatchTime.pause();
                    // Run different response writer depending on if the router
                    // is behind the edge or not.
                    writer = createResponseWriter(route);
                    await route.handler(writer);
                    // Stop running routes if the route has defined the send response,
                    // otherwise continue to the next route.
                    const done = await writer.sendResponse({
                        // We may need to alter the response based on the status code to issue a error page
                        beforeResponse: async (res) => {
                            // We only run the error page handler when accessed via permalink. Otherwise we may execute the
                            // error route in both edge and serverless and that will render the error page for error page rendered by serverless which is incorrect.
                            if (!Router.isRequestFromEdge(req)) {
                                /* istanbul ignore else */
                                for (let errorRoute of errorRoutes) {
                                    routeMatchTime.resume();
                                    if (!errorRoute.matchResponse(res))
                                        continue;
                                    routeMatchTime.pause();
                                    writer = createResponseWriter(errorRoute);
                                    await errorRoute.handler(writer);
                                    writer.sendResponse();
                                    return false;
                                }
                            }
                            // When nothing was matched by error handler or we are behind edge,
                            // return original response.
                            return true;
                        },
                    });
                    if (done) {
                        return;
                    }
                }
                catch (e) {
                    // @ts-ignore
                    writer = writer || createResponseWriter(req, res, route, context);
                    writer.onRouteError(e);
                    return;
                }
            }
            this.builtInFallback(req, res);
        };
        if (!options.excludeBuiltInRoutes) {
            addBuiltInRoutes_1.default(this);
        }
        this.allowReqQueryDuplicates = (_a = options.allowReqQueryDuplicates) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Returns a manifest of all static assets to be served via router.static
     * @private
     */
    getStaticAssetManifest() {
        return RouteGroup_1.staticAssetManifest;
    }
    /**
     * Allows the lambda handler to add the __js__ backend in the cloud
     * @private
     * @param name
     * @param value
     */
    setBackend(name, value) {
        config_1.default.get('backends')[name] = value;
        return this;
    }
    /**
     * Constructs plugin and pushes it to registered plugins
     * @param pluginInstance A plugin to use.
     * @returns {Router} A self-reference, suitable for chaining.
     */
    use(pluginInstance) {
        pluginInstance.onRegister(this);
        this.plugins.push(pluginInstance);
        return this;
    }
    /**
     * Adds a named destination to which you can map traffic using the traffic shaping settings in your environment
     * in Layer0 developer console
     * @param name The name of the destination
     * @param router A router to use when handling requests
     * @returns {Router} A self-reference, suitable for chaining.
     */
    destination(name, router) {
        router.setIndex(this.nextRouterIndex++);
        this.destinations[name] = router;
        return this;
    }
    /**
     * Returns all plugins, including those registered on destination routers.
     */
    getPlugins() {
        let plugins = this.plugins;
        for (let router of Object.values(this.destinations)) {
            plugins = plugins.concat(router.getPlugins());
        }
        return plugins;
    }
    /**
     * Sets the index at which the router has been added to its parent router
     * @private
     * @param index
     */
    setIndex(index) {
        this._index = index;
    }
    /**
     * Returns the index at which the router has been added to its parent router
     * @private
     * @returns router's index
     */
    get index() {
        return this._index;
    }
    /**
     * Adds a RouteGroup to router and calls route register function for group.
     * @private
     * @param name Group name
     * @param registerRoutesFn Group route register function
     * @returns {Router} A self-reference, suitable for chaining.
     */
    group(name, registerRoutesFn) {
        const newGroup = new RouteGroup_1.default(name);
        registerRoutesFn(newGroup);
        this.routeGroups.add(newGroup);
        return this;
    }
    /**
     * Adds a route matching all methods.
     *
     * Example:
     *
     * ```js
     *  new Router().match('/p/:productId', ({ cache, proxy }) => {
     *    cache({
     *      edge: {
     *        maxAgeSeconds: 60 * 60 * 24
     *      }
     *    })
     *
     *    proxy('origin')
     *  })
     * ```
     *
     * @param criteria Either the path as a string or an object with `path`, `method`, and `headers`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    match(criteria, handler) {
        return this.group('root', routeGroup => routeGroup.match(criteria, handler));
    }
    /**
     * Adds preload config for router
     *
     * ```js
     *  new Router().preload(
     *    async () => [{ path: '/foo', headers: { foo: 'bar' } }],
     *    [{ path: '/bar' }]
     *  )
     * ```
     *
     * @param preloadOptions
     */
    prerender(...preloadOptions) {
        this.preloadRequests.push(...preloadOptions);
        return this;
    }
    /**
     * Adds a route matching the given HTTP method.
     *
     * @param method HTTP method
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @private
     */
    matchMethod(method, criteria, handler) {
        if (typeof criteria === 'string') {
            return this.match({
                method,
                path: criteria,
            }, handler);
        }
        if (criteria.method) {
            throw new Error(`Invalid criteria property method passed to call to Router#${method}. Specifying a method in the criteria is redundant.`);
        }
        return this.match({ ...criteria, method }, handler);
    }
    /**
     * Adds a route matching `HEAD` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    head(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.head, criteria, handler);
    }
    /**
     * Adds a route matching `GET` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    get(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.get, criteria, handler);
    }
    /**
     * Adds a route matching `POST` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    post(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.post, criteria, handler);
    }
    /**
     * Adds a route matching `DELETE` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    delete(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.delete, criteria, handler);
    }
    /**
     * Adds a route matching `PUT` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    put(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.put, criteria, handler);
    }
    /**
     * Adds a route matching `PATCH` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    patch(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.patch, criteria, handler);
    }
    /**
     * Adds a route matching `OPTIONS` HTTP method.
     *
     * @param criteria Either the path as a string or an object with `path`, `headers` and `cookies`.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    options(criteria, handler) {
        return this.matchMethod(constants_1.HTTP_METHODS.options, criteria, handler);
    }
    /**
     * Adds a route that will run if no other routes are matched
     * @param handler A handler function that will be called when no other route is matched
     * @returns A self-reference, suitable for chaining.
     */
    fallback(handler) {
        this.routeGroups.setFallback(handler);
        return this;
    }
    /**
     * Adds a route that matches all requests with internal error header.
     * @param handler A handler function that will be called when the route is matched
     * @returns {Router} A self-reference, suitable for chaining.
     */
    catch(error, handler) {
        let errorRegex;
        if (error instanceof RegExp) {
            errorRegex = error;
        }
        else {
            errorRegex = new RegExp(`^${error.toString()}$`);
        }
        this.group(constants_1.ROUTES_CATCH_GROUP, routeGroup => routeGroup.match({ headers: { 'x-0-error-status-code': errorRegex }, response: { statusCode: errorRegex } }, async (writer) => {
            await handler(writer);
            writer.cache({
                edge: false,
                browser: {
                    maxAgeSeconds: 0,
                },
            });
        }));
        return this;
    }
    /**
     * Disables crawling of permalinks by setting the `x-robots-tag: noindex` response header
     * for hosts matching layer0.link or layer0-perma.link.
     *
     * ```js
     *  new Router().noIndexPermalink()
     * ```
     *
     * * @returns {Router} A self-reference, suitable for chaining.
     */
    noIndexPermalink() {
        return this.group(constants_1.ROUTES_NOINDEX_GROUP, routeGroup => routeGroup.match({
            headers: {
                host: /layer0.link|layer0-perma.link/,
            },
        }, ({ setResponseHeader }) => {
            setResponseHeader('x-robots-tag', 'noindex');
        }));
    }
    /**
     * Both edge and @core/router have a built-in fallback that has the following rules:
     *
     * 1. On HTTP protocol return a 301 with the same request path in `location` header but on HTTPS
     * protocol.
     * 2. On HTTPS protocol return a 404.
     *
     * One complication is that in local development HTTPS does not exist - it is only emulated.
     * Therefore in local development we could go into a redirect loop if the HTTP is emulated
     * through the `local_layer0_emulate_http_protocol` cookie. There are a few options:
     *
     * 1. Always return 404 in local development.
     * 2. If the cookie is present, issue 301 but unset the cookie in the response.
     * 3. If the cookie is not present, return 301.
     *
     * We feel that the least surprising is simply always issuing 404 as that is also the original behavior.
     *
     * @param res
     */
    builtInFallback(req, res) {
        const connection = req.connection;
        if (connection && connection.remoteAddress) {
            res.writeHead(404);
        }
        else {
            if (req.headers[constants_1.HTTP_HEADERS.x0Protocol] === 'http') {
                res.setHeader(constants_1.HTTP_HEADERS.location, `https://${req.headers[constants_1.HTTP_HEADERS.host]}${req.url}`);
                res.writeHead(301);
            }
            else {
                res.writeHead(404);
            }
        }
        res.end();
    }
    /**
     * Adds routes for all static assets in a directory tree.
     *
     * **Example**
     *
     * ```js
     *  router.static('public')
     * ```
     *
     * To only serve files matching a particular pattern, use the `glob` options:
     *
     * ```js
     *  router.static('public', {
     *    glob: '*.css'
     *  })
     * ```
     *
     * By default the path on which files are served corresponds to the path within the directory,
     * so for example, `public/css/main.css` would be served at `'/css/main.css'`,
     * you can override this using the `path` option:
     *
     * ```js
     *  router.static('public', {
     *    paths: file => ['/assets/ + file] // will serve public/css/main.css at /assets/css/main.css
     *  })
     * ```
     *
     * You can add caching or other additional handler logic using the `handler` option:
     *
     * ```js
     *  router.static('public', {
     *    handler: (file) => ({ cache }) => {
     *      cache({
     *        browser: {
     *          maxAgeSeconds: 60 * 60
     *        },
     *        edge: {
     *          maxAgeSeconds: 60 * 60 * 24,
     *          staleWhileRevalidateSeconds: 60 * 60
     *        }
     *      })
     *    }
     *  })
     * ```
     *
     * @param sourcePath The path to a directory containing static assets relative to the root of your project.
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    static(sourcePath, options = {}) {
        return this.group('root', routeGroup => routeGroup.static(sourcePath, options));
    }
    /**
     * Shorthand for adding GraphQL body matching
     *
     * Examples:
     *
     * // by default the path is graphql
     * new Router().graphqlOperation("GetRates")
     *
     * or
     *
     * // with optional non-default path
     * new Router().graphqlOperation({ path: "/gql-api", name: "GetRates" })
     *
     * @param criteria Either the operation name as a string or an object with `path`, `name`.
     * @param handler A handler function that will be called when the route is matched
     *
     * @returns A self-reference, suitable for chaining.
     */
    graphqlOperation(criteria, handler) {
        if (typeof criteria === 'string' || criteria instanceof RegExp) {
            return this.post({ path: '/graphql', body: { parse: 'json', criteria: { operationName: criteria } } }, handler);
        }
        else {
            const { path, name } = criteria;
            return this.post({ path, body: { parse: 'json', criteria: { operationName: name } } }, handler);
        }
    }
    /**
     * Adds Basic Authentication.
     *
     * **example**
     *
     * ```js
     *  router
     *    .requireBasicAuth({ username: 'user', password: 's3cr3t!' })
     *    // ...include additional routes below...
     * ```
     *
     * You can also require basic auth for a subset of URLs using the `criteria` option:
     *
     * ```js
     *  router
     *    .requireBasicAuth({ criteria: '/secret/:path*', username: 'user', password: 's3cr3t!' })
     *    // ...include additional routes below...
     * ```
     *
     * The criteria option accepts a path pattern as a string, or a RouteCriteria object.
     *
     * @param options
     * @returns A self-reference, suitable for chaining.
     */
    requireBasicAuth(options) {
        return this.group('root', routeGroup => routeGroup.requireBasicAuth(options));
    }
    /**
     * Returns edge config from current router
     * @private
     */
    createEdgeConfig() {
        return createEdgeConfig_1.default(this);
    }
    /**
     * Returns preload config from current router
     * @private
     */
    createPreloadConfig() {
        return PreloadRequests_1.default.resolvePreloadConfig(this);
    }
    /**
     * @private
     */
    getDestinations() {
        return this.destinations;
    }
    /**
     * @private
     */
    getRouteGroups() {
        return this.routeGroups;
    }
    /**
     * Returns a string summarizing all routes for debugging purposes. Don't rely on the format
     * of this string as we may improve it over time.
     */
    toString() {
        return ('Routes\n======\n' +
            this.routeGroups
                .getRoutes()
                .map((r, i) => `${i}:\t${r.toString()}`)
                .join('\n'));
    }
    /**
     * Returns true if the request came through Layer0 edge.
     *
     * Notes:
     * - If the request came through Layer0 edge then `x-0-version` has been injected.
     *
     * @param req The request
     */
    static isRequestFromEdge(req) {
        return typeof req.headers[constants_1.HTTP_HEADERS.x0Version] == 'string';
    }
}
exports.default = Router;
