"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const universalRouteUtils_1 = require("./universalRouteUtils");
const mapValues_1 = __importDefault(require("../utils/mapValues"));
/**
 * A serializable array of route descriptors to be passed to the browser.
 * @private
 */
class CacheManifest {
    constructor(entries) {
        this.entries = entries || [];
    }
    /**
     * Returns a list of entries in this CacheManifest where both the browser and
     * edge cache times are defined, and greater than 0
     */
    get cacheableEntries() {
        return this.entries.filter(CacheManifest.isEntryCacheable);
    }
    /**
     * Returns a list of routes (as RegExp) that are cacheable SPA routes
     */
    get spaRoutes() {
        return this.cacheableEntries
            .filter(({ cacheOptions }) => cacheOptions.browser && cacheOptions.browser.spa)
            .map(({ route }) => new RegExp(route, 'i'));
    }
    /**
     * Returns true if the URL should be prefetched, based on the matched route's `cacheOptions`
     * @param url The URL to test
     */
    shouldPrefetch(url) {
        let doPrefetch = false;
        this.entries.some(entry => {
            const matches = CacheManifest.entryMatches(entry, url);
            if (matches) {
                doPrefetch =
                    CacheManifest.isEntryCacheable(entry) || !!entry.cacheOptions.prefetchUpstreamRequests;
                // if it's prefetchable, or if it matches a stop route, then no need to continue checking:
                return doPrefetch || entry.returnsResponse;
            }
            return false;
        });
        return doPrefetch;
    }
    /**
     * Returns true if the entry matches the URL's path, query params, and/or protocol
     * @param entry The entry to test
     * @param url URL to check against the entry
     */
    static entryMatches(entry, url) {
        return (new RegExp(entry.route, 'i').test(url.pathname) &&
            universalRouteUtils_1.matchCriteriaRegexObjectWithRequestObject(mapValues_1.default(entry.query || {}, value => (value ? new RegExp(value, 'i') : null)), Object.fromEntries(Array.from(url.searchParams.entries()))) &&
            (entry.protocol ? new RegExp(entry.protocol, 'i').test(url.protocol) : true));
    }
    /**
     * Returns true if the given entry has its `cacheOptions` set so that the route
     * is cacheable by the edge and the browser.
     * @param entry The entry to test
     */
    static isEntryCacheable({ cacheOptions }) {
        return !!(cacheOptions.browser &&
            (cacheOptions.browser.serviceWorkerSeconds || 0) > 0 &&
            cacheOptions.edge &&
            (cacheOptions.edge.maxAgeSeconds || 0) > 0);
    }
    /**
     * Creates a new `CacheManifest` object from the provided serialized entries
     */
    static fromEntries(entries) {
        return new CacheManifest(entries);
    }
    /**
     * Serializes the list so that it can be passed to the browser
     */
    toJSON() {
        return JSON.stringify(this.entries);
    }
}
exports.default = CacheManifest;
