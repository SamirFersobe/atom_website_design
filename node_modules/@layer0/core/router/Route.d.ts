import { RouteHandler } from './Router';
import PathMatcher from './PathMatcher';
import Request from './Request';
import RouteCriteria from './RouteCriteria';
import Response from './Response';
/**
 * @private
 */
export default class Route {
    readonly criteria: RouteCriteria;
    readonly matcher?: PathMatcher;
    readonly handler: RouteHandler;
    readonly options?: RouteOptions;
    /**
     * Creates a new Route
     * @param criteria A string or an object with `path`, `headers`, and `method`.
     * @param handler A route handler
     * @param options A route options
     */
    constructor(criteria: string | RouteCriteria | null, handler: RouteHandler, options: RouteOptions);
    /**
     * Returns params if route matches the request's method, headers, cookies and path.
     * @param req
     * @return The path params if the route matches the current request, otherwise false
     */
    match(req: Request): {};
    /**
     * Matches response. This is used for error routes and each route that contains response matcher is considered as
     * a route for handling the error pages. Each error route must send a response.
     * @param res Response
     * @returns
     */
    matchResponse(res: Response): boolean;
    private matchResponseStatus;
    private matchPath;
    private matchMethod;
    /**
     * Run thru criteria headers and match with request headers.
     *
     * Header names are *not* case-sensitive and they are all lower-cased per Node behavior we pass `toLower` to matcher function.
     *
     * @param req Request object
     */
    private matchHeaders;
    /**
     * Matches JSON body based on given criteria
     *
     * @param req Request object
     *
     * @returns Boolean
     */
    private matchBody;
    /**
     * Run thru criteria query and match with request query parameters.
     *
     * Query string names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    private matchQueryParams;
    /**
     * Run thru criteria cookies and match with request cookies.
     *
     * Cookie names are case-sensitive so we use the default behaviour of
     * `matchCriteriaRegexObjectWithRequestObject`.
     *
     * @param req Request object
     */
    private matchCookies;
    /**
     * Match the protocol for the request. All routes have the implicit `https` protocol
     * unless explicitly specified as something else.
     *
     * Because HTTP is a subset of HTTPS we make sure that when strings are used we match
     * the whole value rather than just a part of it.
     *
     * @param req Request object
     */
    private matchProtocol;
    toString(): string;
    toRegex(): RegExp;
    /**
     * Returns criteria json
     * This is consumed by cache metrics that will transform the route to be as similar as in routes file
     */
    toJson(): string;
    /**
     * Returns a string with the regex representation of the route.
     * @returns Regexp string representation of the route
     */
    toRegexString(): string;
    /**
     * Returns a regex string compatible with the edge regular express parser
     */
    toEdgeRegexString(): string;
    /**
     * Returns if the route should match response criteria.
     *
     * @returns
     */
    isRespRoute(): boolean;
    static toRegexp(path?: string): RegExp;
    static toEdgeRegexString(path?: string): string;
    /**
     * Generate a path-to-regexp comptible path that includes query strings
     * In path-to-regexp, '?' is a special character so it needs to be escaped
     *
     * Note that we prevent querystring from escaping ':', which is used to inject
     * matched params from the path
     *
     * @param path
     * @param query
     */
    static pathWithQueryString(path: string, query: {
        [key: string]: string;
    }): string;
}
export interface RouteOptions {
    /**
     * Adds the label for static routes
     */
    label?: string;
}
