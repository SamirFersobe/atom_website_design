"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
/**
 * Creates a response transformer that assigns surrogate keys for the given body parsed as JSON. Accepts a
 * callback function that takes the response body parsed as json and returns an array of surrogate
 * keys to assign the response when cached. This function will only be called on cache misses. When a request
 * has no body or a body that cannot be parsed as JSON, the callback function will be passed `undefined`.
 * Returning anything other than an array of string will result in no surrogate keys being assigned and a warning
 * will be logged.
 *
 * Example:
 *
 * ```
 *  new Router()
 *    .graphqlOperation('GetPost', ({ cache }) => {
 *      cache({
 *        edge: {
 *          maxAgeSeconds: 60 * 60
 *        }
 *      })
 *      proxy('graphql', {
 *        transformResponse: deriveSurrogateKeysFromJson(json => [`posts.${json.id}`])
 *      })
 *    })
 * ```
 * @param extractKeys
 * @returns
 */
function deriveSurrogateKeysFromJson(extractKeys, options = { onConflict: 'merge' }) {
    return async (res) => {
        const result = extractKeys(parseBodyAsJson(res.body));
        if (!Array.isArray(result)) {
            console.warn(`The function provided to deriveSurrogateKeysFromJson should return an array, but returned a value of type "${typeof result}" instead. Surrogate keys will not be set.`);
            return;
        }
        const keys = new Set(result);
        if (options.onConflict === 'merge') {
            let surrogateKeyFromOrigin = res.getHeader(__1.HTTP_HEADERS.x0SurrogateKey);
            if (surrogateKeyFromOrigin != null) {
                if (!Array.isArray(surrogateKeyFromOrigin)) {
                    surrogateKeyFromOrigin = [surrogateKeyFromOrigin];
                }
                for (let header of surrogateKeyFromOrigin) {
                    for (let key of header.split(' ')) {
                        keys.add(key);
                    }
                }
            }
        }
        else if (options.onConflict !== 'override') {
            throw new Error(`invalid value "${options.onConflict}" for onConflict option in deriveSurrogateKeysFromJson. Use "override" or "merge".`);
        }
        if (keys.size > 0) {
            res.setHeader(__1.HTTP_HEADERS.x0SurrogateKey, Array.from(keys).join(' '));
        }
    };
}
exports.default = deriveSurrogateKeysFromJson;
function parseBodyAsJson(body) {
    if (!body) {
        return undefined;
    }
    try {
        return JSON.parse(typeof body === 'string' ? body : body.toString('utf8'));
    }
    catch (e) {
        return undefined;
    }
}
